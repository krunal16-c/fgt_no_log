<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>friendly_ground_truth.view.fgt_canvas API documentation</title>
<meta name="description" content="File Name: fgt_canvas.py â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>friendly_ground_truth.view.fgt_canvas</code></h1>
</header>
<section id="section-intro">
<p>File Name: fgt_canvas.py</p>
<p>Authors: Kyle Seienthal</p>
<p>Date: 13-05-2020</p>
<p>Description: Canvas widget for displaying and interacting with images.</p>
<p>Code largely adapted from <a href="https://stackoverflow.com/a/48137257">https://stackoverflow.com/a/48137257</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
File Name: fgt_canvas.py

Authors: Kyle Seienthal

Date: 13-05-2020

Description: Canvas widget for displaying and interacting with images.


Code largely adapted from https://stackoverflow.com/a/48137257
&#34;&#34;&#34;
import math
import warnings
import tkinter as tk

import threading

from tkinter import ttk
from PIL import Image, ImageTk

import logging
module_logger = logging.getLogger(&#39;friendly_gt.viewi.fgt_canvas&#39;)


class AutoScrollbar(ttk.Scrollbar):
    &#34;&#34;&#34;
    Self hiding scrollbar.
    &#34;&#34;&#34;

    def set(self, lo, hi):

        if float(lo) &lt;= 0.0 and float(hi) &gt;= 1.0:
            self.grid_remove()
        else:
            self.grid()
            ttk.Scrollbar.set(self, lo, hi)

    def pack(self, **kw):
        raise tk.TclError(&#39;Cannot use pack with the widget &#39; +
                          self.__class__.__name__)

    def place(self, **kw):
        raise tk.TclError(&#39;Cannot use place with the widget &#39; +
                          self.__class__.__name__)


class ScrollableImageCanvas:

    def __init__(self, placeholder, img, main_window, style):

        self._logger = logging.\
            getLogger(&#39;friendly_gt.view.ScrollableImageCanvas&#39;)

        self._style = style

        self.imscale = 1.0  # Scale of the image

        self._main_window = main_window

        self._delta = 1.3  # Zoom magnitude
        self._filter = Image.ANTIALIAS
        self._previous_state = 0  # The previous state of the keyboard
        self._imframe = ttk.Frame(placeholder)

        self.img = img

        # Scrollbars
        hbar = AutoScrollbar(self._imframe, orient=&#39;horizontal&#39;)
        vbar = AutoScrollbar(self._imframe, orient=&#39;vertical&#39;)

        hbar.grid(row=1, column=0, sticky=&#39;we&#39;)
        vbar.grid(row=0, column=1, sticky=&#39;ns&#39;)

        # Create the canvas
        self.canvas = tk.Canvas(self._imframe, highlightthickness=0,
                                xscrollcommand=hbar.set,
                                yscrollcommand=vbar.set)

        self.canvas.grid(row=0, column=0, sticky=&#39;nswe&#39;)

        background = self._style.lookup(&#34;Canvas.TFrame&#34;, &#39;background&#39;)

        self.canvas.config(background=background)
        self.canvas.update()  # Make sure the canvas updates

        self._orig_canvas_x = self.canvas.xview()[0]
        self._orig_canvas_y = self.canvas.yview()[0]

        hbar.configure(command=self._scroll_x)
        vbar.configure(command=self._scroll_y)

        # Bind events to the canvas
        # When the canvas is resized
        self.canvas.bind(&#39;&lt;Configure&gt;&#39;, lambda event: self._show_image())
        # Remember the canvas position
        self.canvas.bind(&#39;&lt;ButtonPress-1&gt;&#39;, self._move_from)

        # Move the canvas
        self.canvas.bind(&#39;&lt;B1-Motion&gt;&#39;, self._move_to)

        # Zoom for Windows and MacOs
        self.canvas.bind(&#39;&lt;MouseWheel&gt;&#39;, self._wheel)
        # Zoom for Linux, scroll down
        self.canvas.bind(&#39;&lt;Button-5&gt;&#39;, self._wheel)
        # Zoom for Linux, scroll up
        self.canvas.bind(&#39;&lt;Button-4&gt;&#39;, self._wheel)

        # Deal with keystrokes in idle mode
        self.canvas.bind(&#39;&lt;Key&gt;&#39;, lambda event:
                         self.canvas.after_idle(self._keystroke, event))

        # Decide if the image is too big
        self._huge = False
        self._huge_size = 14000
        self._band_width = 1024

        Image.MAX_IMAGE_PIXELS = 1000000000

        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;)
            self._image = Image.fromarray(self.img)

        self.imwidth, self.imheight = self._image.size

        if (self.imwidth * self.imheight &gt; self._huge_size * self._huge_size
           and self._image.tile[0][0] == &#39;raw&#39;):

            self._huge = True
            self._offset = self._image.tile[0][2]
            self._tile = [self._image.tile[0][0],
                          [0, 0, self.imwidth, 0],
                          self._offset,
                          self._image.tile[0][3]]

        self._min_side = min(self.imwidth, self.imheight)

        # Image Pyramid
        if self._huge:
            self._pyramid = [self.smaller()]
        else:
            self._pyramid = [Image.fromarray(self.img)]

        # Set ratio coefficeint for pyramid
        if self._huge:
            self._ratio = max(self.imwidth, self.imheight) / self._huge_size
        else:
            self._ratio = 1.0

        self._curr_img = 0  # The current image from the pyramid
        self._scale = self.imscale * self._ratio
        self._reduction = 2  # Reduction degree of pyramid

        w, h, = self._pyramid[-1].size
        while w &gt; 512 and h &gt; 512:
            w /= self._reduction
            h /= self._reduction
            self._pyramid.append(self._pyramid[-1].resize((int(w), int(h)),
                                 self._filter))

        # Put image into rectangle for setting corrdinates
        self.container = self.canvas.create_rectangle((0, 0, self.imwidth,
                                                      self.imheight), width=0)

        self._show_image()
        self.canvas.focus_set()

    def set_image(self, img):
        self.img = img
        self._show_image()
        self.canvas.focus_set()

    def set_theme(self, style):
        background = self._style.lookup(&#34;Canvas.TFrame&#34;, &#39;background&#39;)

        self.canvas.config(background=background)

    def smaller(self):
        &#34;&#34;&#34;
        Resize the image to be smaller.


        Returns:
            A resized PIL image
        &#34;&#34;&#34;
        w1, h1 = float(self.imwidth), float(self.imheight)
        w2, h2 = float(self._huge_size), float(self._huge_size)

        aspect_ratio1 = w1 / h1
        aspect_ratio2 = w2 / h2

        if aspect_ratio1 == aspect_ratio2:
            image = Image.new(&#39;RGB&#39;, (int(w2), int(h2)))
            k = h2 / h1  # Compression ratio
            w = int(w2)  # Band length
        elif aspect_ratio1 &gt; aspect_ratio2:
            image = Image.new(&#39;RGB&#39;, (int(w2), int(w2 / aspect_ratio1)))
            k = h2 / w1
            w = int(w2)
        else:  # aspect_ratio1 &lt; aspect_ratio2
            image = Image.new(&#39;RGB&#39;, (int(h2 * aspect_ratio1), int(h2)))
            k = h2 / h1
            w = int(h2 * aspect_ratio1)

        i, j, _ = 0, 1, round(0.5 + self.imheight / self._band_width)

        while i &lt; self.imheight:
            # Width of the tile band
            band = min(self._band_width, self.imheight - i)

            self._tile[1][3] = band

            # Tile offset (3 bytes per pixel)
            self._tile[2] = self._offset + self.imwidth * i * 3
            self._image.close()
            self._image = Image.fromarray(self.img)
            self._image.size = (self.imwidth * band)
            self._image.tile = [self._tile]

            cropped = self._image.crop((0, 0, self.imwidth, band))  # crop
            image.paste(cropped.resize((w, int(band * k)+1), self._filer), (0,
                        int(i * k)))

            i += band
            j += 1

        return image

    def redraw_figures(self):
        &#34;&#34;&#34;
        Dummy function for redrawing in children classes


        Returns:
            None
        &#34;&#34;&#34;
        pass

    def grid(self, **kw):
        &#34;&#34;&#34;
        Put the Canvas widget on the parent widget.

        Args:
            **kw: Kwargs

        Returns:
            None
        &#34;&#34;&#34;
        self._imframe.grid(**kw)  # Put the canvas on the grid
        self._imframe.grid(sticky=&#39;nswe&#39;)  # Make frame sticky
        self._imframe.rowconfigure(0, weight=1)  # Make canvas expandable
        self._imframe.columnconfigure(0, weight=1)

    def pack(self, **kw):
        &#34;&#34;&#34;
        Cannot use pack.

        Args:
            **kw: Kwargs

        Returns:
            None

        Raises:
            Exception, you can&#39;t use the pack function.
        &#34;&#34;&#34;
        raise Exception(&#39;Cannot use pack with the widget &#39; +
                        self._class_._name_)

    def place(self, **kw):
        &#34;&#34;&#34;
        The place method of the tkinter widget.

        Args:
            **kw: kwargs

        Returns:
            None

        Raises:
            An exception, as this cannot be used with this widget.
        &#34;&#34;&#34;
        raise Exception(&#39;Cannot use place with the widget &#39; +
                        self._class_._name_)

    # noinspection PyUnusedLocal
    def _scroll_x(self, *args, **kwargs):
        &#34;&#34;&#34;
        Scroll in the x direction.

        Args:
            *args: args
            **kwargs: kwargs

        Returns:
            None

        Postconditions:
            The canvas is scrolled horizontally.
        &#34;&#34;&#34;
        self.canvas.xview(*args)  # scroll horizontally
        self._show_image()  # redraw the image

    # noinspection PyUnusedLocal
    def _scroll_y(self, *args, **kwargs):
        &#34;&#34;&#34;
        Scroll in the y direction

        Args:
            *args: args
            **kwargs: kwargs

        Returns:
            None

        Postconditions:
            The canvas is scrolled vertically.
        &#34;&#34;&#34;
        self.canvas.yview(*args)  # scroll vertically
        self._show_image()  # redraw the image

    def _show_image(self):
        &#34;&#34;&#34;
        Display the current image


        Returns:
            None

        Postconditions:
            The image is drawn on the canvas.
        &#34;&#34;&#34;
        box_image = self.canvas.coords(self.container)  # get image area
        box_canvas = (self.canvas.canvasx(0),  # get visible area of the canvas
                      self.canvas.canvasy(0),
                      self.canvas.canvasx(self.canvas.winfo_width()),
                      self.canvas.canvasy(self.canvas.winfo_height()))

        # convert to integer or it will not work properly
        box_img_int = tuple(map(int, box_image))  # Get scroll region box

        box_img_width = box_img_int[2] - box_img_int[0]

        xscale = box_img_width/self.img.shape[1]

        self._coord_scale = xscale

        box_scroll = [min(box_img_int[0], box_canvas[0]),
                      min(box_img_int[1], box_canvas[1]),
                      max(box_img_int[2], box_canvas[2]),
                      max(box_img_int[3], box_canvas[3])]

        # Horizontal part of the image is in the visible area
        if box_scroll[0] == box_canvas[0] and box_scroll[2] == box_canvas[2]:
            box_scroll[0] = box_img_int[0]
            box_scroll[2] = box_img_int[2]
        # Vertical part of the image is in the visible area
        if box_scroll[1] == box_canvas[1] and box_scroll[3] == box_canvas[3]:
            box_scroll[1] = box_img_int[1]
            box_scroll[3] = box_img_int[3]
        # Convert scroll region to tuple and to integer
        # set scroll region
        self.canvas.configure(scrollregion=tuple(map(int, box_scroll)))

        # get coordinates (x1,y1,x2,y2) of the image tile
        x1 = max(box_canvas[0] - box_image[0], 0)
        y1 = max(box_canvas[1] - box_image[1], 0)
        x2 = min(box_canvas[2], box_image[2]) - box_image[0]
        y2 = min(box_canvas[3], box_image[3]) - box_image[1]

        # show image if it in the visible area
        if int(x2 - x1) &gt; 0 and int(y2 - y1) &gt; 0:
            if self._huge and self._curr_img &lt; 0:  # show huge image
                h = int((y2 - y1) / self.imscale)  # height of the tile band
                self._tile[1][3] = h  # set the tile band height
                self._tile[2] = (self._offset + self.imwidth *
                                 int(y1 / self.imscale) * 3)
                self._image.close()
                self._image = Image.open(self.path)  # reopen / reset image
                # set size of the tile band
                self._image.size = (self.imwidth, h)
                self._image.tile = [self._tile]
                image = self._image.crop((int(x1 / self.imscale), 0,
                                          int(x2 / self.imscale), h))
            else:  # show normal image
                # crop current img from pyramid
                image = self._pyramid[max(0, self._curr_img)].crop(
                                    (int(x1 / self._scale),
                                     int(y1 / self._scale),
                                     int(x2 / self._scale),
                                     int(y2 / self._scale)))
            #
            imagetk = ImageTk.PhotoImage(image.resize((int(x2 - x1),
                                         int(y2 - y1)), self._filter))

            imageid = self.canvas.create_image(max(box_canvas[0],
                                               box_img_int[0]),
                                               max(box_canvas[1],
                                               box_img_int[1]),
                                               anchor=&#39;nw&#39;, image=imagetk)
            self.canvas.lower(imageid)  # set image into background
            # keep an extra reference to prevent garbage-collection
            self.canvas.imagetk = imagetk
            self._image_id = imageid

    def _move_from(self, event):
        &#34;&#34;&#34;
        Mark the position of the canvas to move from using scanning.

        Args:
            event: The mouse event

        Returns:
            None

        Postconditions:
            The canvas will have a scan mark at the event position.
        &#34;&#34;&#34;
        self.canvas.scan_mark(event.x, event.y)

    def _move_to(self, event):
        &#34;&#34;&#34;
        Move the canvas to the event position.

        Args:
            event: The mouse event.

        Returns:
            None

        Postconditions:
            The canvas is moved to the event position.
        &#34;&#34;&#34;
        self.canvas.scan_dragto(event.x, event.y, gain=1)

        self._show_image()  # zoom tile and show it on the canvas

    def outside(self, x, y):
        &#34;&#34;&#34;
        Check it the input point is inside the image area.

        Args:
            x: The x coordinate
            y: The y coordinate

        Returns:
            True if the point is inside the image.
            False if the point is outside the image.
        &#34;&#34;&#34;
        bbox = self.canvas.coords(self.container)  # get image area
        if bbox[0] &lt; x &lt; bbox[2] and bbox[1] &lt; y &lt; bbox[3]:
            return False  # point (x,y) is inside the image area
        else:
            return True  # point (x,y) is outside the image area

    def set_zoom(self, factor):
        x, y = 0, 0
        scale = 1.0
        if factor &lt; 0:
            if round(self._min_side * self.imscale) &lt; 30:
                return  # image is less than 30 pixels
            self.imscale /= (self._delta * (-factor))
            scale /= (self._delta * (-factor))

        if factor &gt; 0:
            i = min(self.canvas.winfo_width(), self.canvas.winfo_height()) &gt;&gt; 1
            if i &lt; self.imscale:
                return  # 1 pixel is bigger than the visible area
            self.imscale *= self._delta
            scale *= self._delta

        # Take appropriate image from the pyramid
        k = self.imscale * self._ratio  # temporary coefficient
        self._curr_img = min((-1) * int(math.log(k, self._reduction)),
                             len(self._pyramid) - 1)
        self._scale = k * math.pow(self._reduction, max(0, self._curr_img))
        #
        self.canvas.scale(&#39;all&#39;, x, y, scale, scale)  # rescale all objects
        # Redraw some figures before showing image on the screen
        self.redraw_figures()  # method for child classes
        self._show_image()

    def _wheel(self, event):
        &#34;&#34;&#34;
        Called when the mouse wheel is scrolled.

        Args:
            event: The mouse event.

        Returns:
            None

        Postconditions:
            The image on the canvas is zoomed.
        &#34;&#34;&#34;
        # get coordinates of the event on the canvas
        x = self.canvas.canvasx(event.x)
        y = self.canvas.canvasy(event.y)
        if self.outside(x, y):
            return  # zoom only inside image area

        # Don&#39;t scroll if control is down
        if event.state - self._previous_state == 4:
            return

        scale = 1.0
        # Respond to Linux (event.num) or Windows (event.delta) wheel event
        if event.num == 5 or event.delta == -120:  # scroll down, smaller
            if round(self._min_side * self.imscale) &lt; 30:
                return  # image is less than 30 pixels
            self.imscale /= self._delta
            scale /= self._delta
        if event.num == 4 or event.delta == 120:  # scroll up, bigger
            i = min(self.canvas.winfo_width(), self.canvas.winfo_height()) &gt;&gt; 1
            if i &lt; self.imscale:
                return  # 1 pixel is bigger than the visible area
            self.imscale *= self._delta
            scale *= self._delta
        # Take appropriate image from the pyramid
        k = self.imscale * self._ratio  # temporary coefficient
        self._curr_img = min((-1) * int(math.log(k, self._reduction)),
                             len(self._pyramid) - 1)
        self._scale = k * math.pow(self._reduction, max(0, self._curr_img))
        #
        self.canvas.scale(&#39;all&#39;, x, y, scale, scale)  # rescale all objects
        # Redraw some figures before showing image on the screen
        self.redraw_figures()  # method for child classes
        self._show_image()

    def _keystroke(self, event):
        &#34;&#34;&#34;
        Called when the keybord is used.

        Args:
            event: The keyboard event.

        Returns:
            None

        Postconditions:
            The canvas is modified according to the key pressed.
        &#34;&#34;&#34;
        # means that the Control key is pressed
        if event.state - self._previous_state == 4:
            pass  # do nothing if Control key is pressed
        else:
            # remember the last keystroke state
            self._previous_state = event.state

    def crop(self, bbox):
        &#34;&#34;&#34;
        Crop the image using the given bounding box.

        Args:
            bbox: The bounding box, a list

        Returns:
            The cropped image.
        &#34;&#34;&#34;
        if self._huge:  # image is huge and not totally in RAM
            band = bbox[3] - bbox[1]  # width of the tile band
            self._tile[1][3] = band  # set the tile height
            # set offset of the band
            self._tile[2] = self._offset + self.imwidth * bbox[1] * 3
            self._image.close()
            self._image = Image.open(self.path)  # reopen / reset image
            # set size of the tile band
            self._image.size = (self.imwidth, band)
            self._image.tile = [self._tile]
            return self._image.crop((bbox[0], 0, bbox[2], band))
        else:  # image is totally in RAM
            return self._pyramid[0].crop(bbox)

    def destroy(self):
        &#34;&#34;&#34; ImageFrame destructor &#34;&#34;&#34;
        self._image.close()
        map(lambda i: i.close, self._pyramid)  # close all pyramid images
        del self._pyramid[:]  # delete pyramid list
        del self._pyramid  # delete pyramid variable
        self.canvas.destroy()
        self._imframe.destroy()


class PatchNavCanvas(ScrollableImageCanvas):

    def __init__(self, placeholder, img, main_window, style):

        self._logger = logging.getLogger(&#39;friendly_gt.view.FGTCanvas&#39;)

        super(PatchNavCanvas, self).__init__(placeholder, img, main_window,
                                             style)

        borderwidth = self._style.lookup(&#34;Preview.TFrame&#34;, &#39;borderwidth&#39;)

        relief = self._style.lookup(&#34;Preview.TFrame&#34;, &#39;relief&#39;)

        self.canvas.config(borderwidth=borderwidth, relief=relief)

        self.canvas.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self._on_click_release)

        self._dragged = False

    def _on_click_release(self, event):
        &#34;&#34;&#34;
        Called when the left mouse button is released.

        Args:
            event: The mouse event.

        Returns:
            None
        &#34;&#34;&#34;

        if self._dragged:
            self._dragged = False
            return

        pos = self.canvas.canvasx(event.x), self.canvas.canvasy(event.y)

        container_coords = self.canvas.coords(self.container)
        pos = pos[0] - container_coords[0], pos[1] - container_coords[1]

        pos = pos[0] / self._coord_scale, pos[1] / self._coord_scale

        self._main_window.navigate_to_patch(pos)

    def set_image(self, image):

        self.img = image
        self._image = Image.fromarray(image)

        pyramid_index = max(0, self._curr_img)

        old_img = self._pyramid[pyramid_index]

        new_image = self._image.resize(old_img.size, self._filter)

        self._pyramid[pyramid_index] = new_image

        self._show_image()

        t = threading.Thread(target=self.recompute_pyramid, name=&#34;pyramid&#34;)
        t.daemon = True
        t.start()

    def new_image(self, image, patch_offset=(0, 0)):
        &#34;&#34;&#34;
        Reset the image and all properties of the image on the canvas.

        Args:
            image: The image, a numpy array.
            patch_offset: The offset of the current patch within the image

        Returns:
            None
        &#34;&#34;&#34;
        self.imscale = 1.0

        self.canvas.delete(&#34;all&#34;)
        self.img = image

        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;)
            self._image = Image.fromarray(self.img)

        self.imwidth, self.imheight = self._image.size

        if (self.imwidth * self.imheight &gt; self._huge_size * self._huge_size
           and self._image.tile[0][0] == &#39;raw&#39;):

            self._huge = True
            self._offset = self._image.tile[0][2]
            self._tile = [self._image.tile[0][0],
                          [0, 0, self.imwidth, 0],
                          self._offset,
                          self._image.tile[0][3]]

        self._min_side = min(self.imwidth, self.imheight)

        # Image Pyramid
        if self._huge:
            self._pyramid = [self.smaller()]
        else:
            self._pyramid = [Image.fromarray(self.img)]

        # Set ratio coefficeint for pyramid
        if self._huge:
            self._ratio = max(self.imwidth, self.imheight) / self._huge_size
        else:
            self._ratio = 1.0

        self._curr_img = 0  # The current image from the pyramid
        self._scale = self.imscale * self._ratio
        self._reduction = 2  # Reduction degree of pyramid

        w, h, = self._pyramid[-1].size
        while w &gt; 512 and h &gt; 512:
            w /= self._reduction
            h /= self._reduction
            self._pyramid.append(self._pyramid[-1].resize((int(w), int(h)),
                                 self._filter))

        # Put image into rectangle for setting corrdinates
        self.container = self.canvas.create_rectangle((0, 0, self.imwidth,
                                                      self.imheight), width=0)

        self._show_image()

    def recompute_pyramid(self):

        new_pyramid = []
        for img in self._pyramid:
            new_image = self._image.resize(img.size, self._filter)
            new_pyramid.append(new_image)

        self._pyramid = new_pyramid

    def _move_to(self, event):
        &#34;&#34;&#34;
        Move the canvas to the event position.

        Args:
            event: The mouse event.

        Returns:
            None

        Postconditions:
            The canvas is moved to the event position.
        &#34;&#34;&#34;
        self._dragged = True

        super()._move_to(event)


class FGTCanvas(ScrollableImageCanvas):
    &#34;&#34;&#34;
    A canvas that allows panning and zooming of large images.

    Attributes:
        imscale: The current scale of the image
        cursor: The current cursor to use on the image
    &#34;&#34;&#34;

    def __init__(self, placeholder, img, main_window, style):

        self._logger = logging.getLogger(&#39;friendly_gt.view.FGTCanvas&#39;)

        super(FGTCanvas, self).__init__(placeholder, img, main_window, style)

        self._previous_position = (0, 0)
        self._coord_scale = 1
        self._dragged = False
        self._prev_offset = (0, 0)
        self._drag_id = &#39;&#39;
        self._unique_drag_id = 0
        self._is_right_drag = False

        # Bind events to the canvas
        self.canvas.bind(&#39;&lt;ButtonRelease-1&gt;&#39;, self._on_click_release)

        # Move the canvas
        self.canvas.bind(&#39;&lt;B2-Motion&gt;&#39;, self._right_drag)
        self.canvas.bind(&#39;&lt;ButtonPress-2&gt;&#39;, self._right_click)
        self.canvas.bind(&#39;&lt;B3-Motion&gt;&#39;, self._right_drag)
        self.canvas.bind(&#39;&lt;ButtonPress-3&gt;&#39;, self._right_click)

        # Cursor stuff
        self.canvas.bind(&#39;&lt;Motion&gt;&#39;, self._on_motion)
        self.canvas.bind(&#39;&lt;Enter&gt;&#39;, self._set_cursor)
        self.canvas.bind(&#39;&lt;Leave&gt;&#39;, self._default_cursor)
        self.canvas.bind(&#39;&lt;FocusOut&gt;&#39;, self._default_cursor)
        self.canvas.bind(&#39;&lt;FocusIn&gt;&#39;, self._set_cursor)

        self._cursor = &#34;arrow&#34;
        self._brush_cursor = None
        self._brush_radius = None

    @property
    def cursor(self):
        return self._cursor

    @cursor.setter
    def cursor(self, value):
        self._cursor = value
        self._set_cursor(None)

    @property
    def brush_radius(self):
        return self._brush_radius

    @brush_radius.setter
    def brush_radius(self, value):
        self._brush_radius = value
        self.draw_brush()

    def new_image(self, image, patch_offset=(0, 0)):
        &#34;&#34;&#34;
        Reset the image and all properties of the image on the canvas.

        Args:
            image: The image, a numpy array.
            patch_offset: The offset of the current patch within the image

        Returns:
            None
        &#34;&#34;&#34;
        self.imscale = 1.0

        self.canvas.delete(&#34;all&#34;)
        self.img = image

        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;)
            self._image = Image.fromarray(self.img)

        self.imwidth, self.imheight = self._image.size

        if (self.imwidth * self.imheight &gt; self._huge_size * self._huge_size
           and self._image.tile[0][0] == &#39;raw&#39;):

            self._huge = True
            self._offset = self._image.tile[0][2]
            self._tile = [self._image.tile[0][0],
                          [0, 0, self.imwidth, 0],
                          self._offset,
                          self._image.tile[0][3]]

        self._min_side = min(self.imwidth, self.imheight)

        # Image Pyramid
        if self._huge:
            self._pyramid = [self.smaller()]
        else:
            self._pyramid = [Image.fromarray(self.img)]

        # Set ratio coefficeint for pyramid
        if self._huge:
            self._ratio = max(self.imwidth, self.imheight) / self._huge_size
        else:
            self._ratio = 1.0

        self._curr_img = 0  # The current image from the pyramid
        self._scale = self.imscale * self._ratio
        self._reduction = 2  # Reduction degree of pyramid

        w, h, = self._pyramid[-1].size
        while w &gt; 512 and h &gt; 512:
            w /= self._reduction
            h /= self._reduction
            self._pyramid.append(self._pyramid[-1].resize((int(w), int(h)),
                                 self._filter))

        # Put image into rectangle for setting corrdinates
        self.container = self.canvas.create_rectangle((0, 0, self.imwidth,
                                                      self.imheight), width=0)

        self._show_image()

        # Deal with 0 offsets in the y coordinate
        if patch_offset[1] == 0 and patch_offset[0] != 0:
            patch_offset = patch_offset[0], self._prev_offset[1]

        self._prev_offset = patch_offset

        # The anchor point will be moved to (0, 0) in the window
        # We want to account for the patch offset, but not put the current
        # patch right in the corner
        anchorx = -self.canvas.canvasx(0 - (patch_offset[1]/2))
        anchory = -self.canvas.canvasy(0 - (patch_offset[0]/2))

        self.canvas.scan_mark(int(anchorx), int(anchory))
        self.canvas.scan_dragto(0, 0, gain=1)
        self.canvas.focus_set()

        self._show_image()

    def _on_motion(self, event):
        &#34;&#34;&#34;
        Called when the mouse is moved.

        Args:
            event: The mouse event.

        Returns:
            None

        Postconditions:
            The mouse cursor is drawn.
            Previous position is set.
        &#34;&#34;&#34;
        x = self.canvas.canvasx(event.x)
        y = self.canvas.canvasy(event.y)
        pos = (x, y)

        if self._cursor == &#34;brush&#34;:
            self.draw_brush(pos)

        self._previous_position = pos

    def _wheel(self, event):

        super()._wheel(event)

        if self._cursor != &#34;brush&#34;:
            self._main_window.log_zoom_event(self.imscale)

    def _set_cursor(self, event):
        &#34;&#34;&#34;
        Set the cursor to the current specified icon.

        Args:
            event: Event

        Returns:
            None
        &#34;&#34;&#34;
        if self._cursor == &#34;brush&#34;:
            self.canvas.config(cursor=&#34;none&#34;)
            self.draw_brush()
        else:
            self.canvas.config(cursor=self._cursor)
            if self._brush_cursor is not None:
                self.canvas.delete(self._brush_cursor)

    def _default_cursor(self, event):
        &#34;&#34;&#34;
        Set the cursor back to the default.

        Args:
            event: The event

        Returns:
            None
        &#34;&#34;&#34;
        self.canvas.config(cursor=&#34;arrow&#34;)
        self._previous_position = (50, 50)

    def draw_brush(self, pos=None):
        &#34;&#34;&#34;
        Draw the paintbrush cursor

        Args:
            pos: The position to draw the brush at.  The default value is None.

        Returns:
            None

        Postcondition:
            The brush is drawn on the canvas/
        &#34;&#34;&#34;
        if self._brush_cursor is not None:
            self.canvas.delete(self._brush_cursor)

        if self._brush_radius is None:
            self._brush_radius = 15

        if pos is None:
            pos = self._previous_position

        x_max = pos[0] + (self._brush_radius * self._coord_scale)
        x_min = pos[0] - (self._brush_radius * self._coord_scale)
        y_max = pos[1] + (self._brush_radius * self._coord_scale)
        y_min = pos[1] - (self._brush_radius * self._coord_scale)

        self._brush_cursor = self.canvas.create_oval(x_max, y_max, x_min,
                                                     y_min,
                                                     outline=&#39;white&#39;,
                                                     tag=&#39;brush&#39;)

    def _move_from(self, event):
        &#34;&#34;&#34;
        Mark the position of the canvas to move from using scanning.

        Args:
            event: The mouse event

        Returns:
            None

        Postconditions:
            The canvas will have a scan mark at the event position.
        &#34;&#34;&#34;
        if self._cursor != &#34;brush&#34;:
            self.canvas.scan_mark(event.x, event.y)

        log_pos = self._get_container_relative_coords(event.x, event.y)
        self._main_window.log_mouse_event(log_pos, &#34;click&#34;, &#34;left_mouse&#34;)

        self._drag_start = event.x, event.y

    def _right_click(self, event):
        &#34;&#34;&#34;
        For dragging with right mouse button.

        Args:
            event: The mouse event.

        Returns:
            None
        &#34;&#34;&#34;
        self.canvas.scan_mark(event.x, event.y)

        log_pos = self._get_container_relative_coords(event.x, event.y)

        self._main_window.log_mouse_event(log_pos, &#34;click&#34;, &#34;right_mouse&#34;)

    def _on_click_release(self, event):
        &#34;&#34;&#34;
        Called when the left mouse button is released.

        Args:
            event: The mouse event.

        Returns:
            None
        &#34;&#34;&#34;

        if self._dragged:
            self._dragged = False
            return

        pos = self._get_container_relative_coords(event.x, event.y)
        # pos = self.canvas.canvasx(event.x), self.canvas.canvasy(event.y)

        # container_coords = self.canvas.coords(self.container)
        # pos = pos[0] - container_coords[0], pos[1] - container_coords[1]

        # pos = pos[0] / self._coord_scale, pos[1] / self._coord_scale
        self._main_window.on_canvas_click(pos)

        self._main_window.log_mouse_event(pos, &#34;release&#34;, &#34;left_mouse&#34;)

    def _get_container_relative_coords(self, x, y):

        pos = self.canvas.canvasx(x), self.canvas.canvasy(y)

        container_coords = self.canvas.coords(self.container)
        pos = pos[0] - container_coords[0], pos[1] - container_coords[1]

        pos = pos[0] / self._coord_scale, pos[1] / self._coord_scale

        return pos

    def _move_to(self, event):
        &#34;&#34;&#34;
        Move the canvas to the event position.

        Args:
            event: The mouse event.

        Returns:
            None

        Postconditions:
            The canvas is moved to the event position.
        &#34;&#34;&#34;
        self._dragged = True

        if self._drag_id == &#39;&#39;:
            self._logger.debug(&#34;Drag start&#34;)
        else:
            self._main_window._master.after_cancel(self._drag_id)

        self._drag_id = self._main_window._master.\
            after(300, self._stop_dragging)

        if self._cursor != &#34;brush&#34;:

            self.canvas.scan_dragto(event.x, event.y, gain=1)

        if self._cursor == &#34;brush&#34;:

            pos = self.canvas.canvasx(event.x), self.canvas.canvasy(event.y)
            self._previous_position = pos
            container_coords = self.canvas.coords(self.container)
            pos = pos[0] - container_coords[0], pos[1] - container_coords[1]
            pos = pos[0] / self._coord_scale, pos[1] / self._coord_scale

            self._main_window.on_canvas_drag(pos, drag_id=self._unique_drag_id)

            brush_pos = (self.canvas.canvasx(event.x),
                         self.canvas.canvasy(event.y))

            self.draw_brush(brush_pos)

        self._show_image()  # zoom tile and show it on the canvas
        self._drag_end = event.x, event.y

    def _stop_dragging(self):
        self._drag_id = &#39;&#39;
        self._unique_drag_id += 1

        start_pos = self._get_container_relative_coords(self._drag_start[0],
                                                        self._drag_start[1])

        end_pos = self._get_container_relative_coords(self._drag_end[0],
                                                      self._drag_end[1])

        if self._is_right_drag or self._cursor != &#39;brush&#39;:

            self._main_window.log_drag_event(&#34;pan&#34;, start_pos, end_pos)
        else:
            self._main_window.log_drag_event(&#34;brush&#34;, start_pos, end_pos)

        self._id_right_drag = False

    def _right_drag(self, event):
        &#34;&#34;&#34;
        Drag with the right mouse button.

        Args:
            event: The mouse event.

        Returns:
            None
        &#34;&#34;&#34;
        if self._drag_id == &#39;&#39;:
            self._logger.debug(&#34;Drag start&#34;)
        else:
            self._main_window._master.after_cancel(self._drag_id)

        self._drag_id = self._main_window._master.\
            after(300, self._stop_dragging)

        self.canvas.scan_dragto(event.x, event.y, gain=1)

        self._show_image()
        self._is_right_drag = True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="friendly_ground_truth.view.fgt_canvas.AutoScrollbar"><code class="flex name class">
<span>class <span class="ident">AutoScrollbar</span></span>
<span>(</span><span>master=None, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>Self hiding scrollbar.</p>
<p>Construct a Ttk Scrollbar with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS</p>
<pre><code>command, orient
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutoScrollbar(ttk.Scrollbar):
    &#34;&#34;&#34;
    Self hiding scrollbar.
    &#34;&#34;&#34;

    def set(self, lo, hi):

        if float(lo) &lt;= 0.0 and float(hi) &gt;= 1.0:
            self.grid_remove()
        else:
            self.grid()
            ttk.Scrollbar.set(self, lo, hi)

    def pack(self, **kw):
        raise tk.TclError(&#39;Cannot use pack with the widget &#39; +
                          self.__class__.__name__)

    def place(self, **kw):
        raise tk.TclError(&#39;Cannot use place with the widget &#39; +
                          self.__class__.__name__)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Scrollbar</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Scrollbar</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.view.fgt_canvas.AutoScrollbar.pack"><code class="name flex">
<span>def <span class="ident">pack</span></span>(<span>self, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>Pack a widget in the parent widget. Use as options:
after=widget - pack it after you have packed widget
anchor=NSEW (or subset) - position widget according to
given direction
before=widget - pack it before you will pack widget
expand=bool - expand widget if parent size grows
fill=NONE or X or Y or BOTH - fill widget if widget grows
in=master - use master to contain this widget
in_=master - see 'in' option description
ipadx=amount - add internal padding in x direction
ipady=amount - add internal padding in y direction
padx=amount - add padding in x direction
pady=amount - add padding in y direction
side=TOP or BOTTOM or LEFT or RIGHT -
where to add this widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack(self, **kw):
    raise tk.TclError(&#39;Cannot use pack with the widget &#39; +
                      self.__class__.__name__)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.AutoScrollbar.place"><code class="name flex">
<span>def <span class="ident">place</span></span>(<span>self, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>Place a widget in the parent widget. Use as options:
in=master - master relative to which the widget is placed
in_=master - see 'in' option description
x=amount - locate anchor of this widget at position x of master
y=amount - locate anchor of this widget at position y of master
relx=amount - locate anchor of this widget between 0.0 and 1.0
relative to width of master (1.0 is right edge)
rely=amount - locate anchor of this widget between 0.0 and 1.0
relative to height of master (1.0 is bottom edge)
anchor=NSEW (or subset) - position anchor according to given direction
width=amount - width of this widget in pixel
height=amount - height of this widget in pixel
relwidth=amount - width of this widget between 0.0 and 1.0
relative to width of master (1.0 is the same width
as the master)
relheight=amount - height of this widget between 0.0 and 1.0
relative to height of master (1.0 is the same
height as the master)
bordermode="inside" or "outside" - whether to take border width of
master widget into account</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def place(self, **kw):
    raise tk.TclError(&#39;Cannot use place with the widget &#39; +
                      self.__class__.__name__)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.AutoScrollbar.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, lo, hi)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the fractional values of the slider position (upper and
lower ends as value between 0 and 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, lo, hi):

    if float(lo) &lt;= 0.0 and float(hi) &gt;= 1.0:
        self.grid_remove()
    else:
        self.grid()
        ttk.Scrollbar.set(self, lo, hi)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.FGTCanvas"><code class="flex name class">
<span>class <span class="ident">FGTCanvas</span></span>
<span>(</span><span>placeholder, img, main_window, style)</span>
</code></dt>
<dd>
<div class="desc"><p>A canvas that allows panning and zooming of large images.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>imscale</code></strong></dt>
<dd>The current scale of the image</dd>
<dt><strong><code>cursor</code></strong></dt>
<dd>The current cursor to use on the image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FGTCanvas(ScrollableImageCanvas):
    &#34;&#34;&#34;
    A canvas that allows panning and zooming of large images.

    Attributes:
        imscale: The current scale of the image
        cursor: The current cursor to use on the image
    &#34;&#34;&#34;

    def __init__(self, placeholder, img, main_window, style):

        self._logger = logging.getLogger(&#39;friendly_gt.view.FGTCanvas&#39;)

        super(FGTCanvas, self).__init__(placeholder, img, main_window, style)

        self._previous_position = (0, 0)
        self._coord_scale = 1
        self._dragged = False
        self._prev_offset = (0, 0)
        self._drag_id = &#39;&#39;
        self._unique_drag_id = 0
        self._is_right_drag = False

        # Bind events to the canvas
        self.canvas.bind(&#39;&lt;ButtonRelease-1&gt;&#39;, self._on_click_release)

        # Move the canvas
        self.canvas.bind(&#39;&lt;B2-Motion&gt;&#39;, self._right_drag)
        self.canvas.bind(&#39;&lt;ButtonPress-2&gt;&#39;, self._right_click)
        self.canvas.bind(&#39;&lt;B3-Motion&gt;&#39;, self._right_drag)
        self.canvas.bind(&#39;&lt;ButtonPress-3&gt;&#39;, self._right_click)

        # Cursor stuff
        self.canvas.bind(&#39;&lt;Motion&gt;&#39;, self._on_motion)
        self.canvas.bind(&#39;&lt;Enter&gt;&#39;, self._set_cursor)
        self.canvas.bind(&#39;&lt;Leave&gt;&#39;, self._default_cursor)
        self.canvas.bind(&#39;&lt;FocusOut&gt;&#39;, self._default_cursor)
        self.canvas.bind(&#39;&lt;FocusIn&gt;&#39;, self._set_cursor)

        self._cursor = &#34;arrow&#34;
        self._brush_cursor = None
        self._brush_radius = None

    @property
    def cursor(self):
        return self._cursor

    @cursor.setter
    def cursor(self, value):
        self._cursor = value
        self._set_cursor(None)

    @property
    def brush_radius(self):
        return self._brush_radius

    @brush_radius.setter
    def brush_radius(self, value):
        self._brush_radius = value
        self.draw_brush()

    def new_image(self, image, patch_offset=(0, 0)):
        &#34;&#34;&#34;
        Reset the image and all properties of the image on the canvas.

        Args:
            image: The image, a numpy array.
            patch_offset: The offset of the current patch within the image

        Returns:
            None
        &#34;&#34;&#34;
        self.imscale = 1.0

        self.canvas.delete(&#34;all&#34;)
        self.img = image

        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;)
            self._image = Image.fromarray(self.img)

        self.imwidth, self.imheight = self._image.size

        if (self.imwidth * self.imheight &gt; self._huge_size * self._huge_size
           and self._image.tile[0][0] == &#39;raw&#39;):

            self._huge = True
            self._offset = self._image.tile[0][2]
            self._tile = [self._image.tile[0][0],
                          [0, 0, self.imwidth, 0],
                          self._offset,
                          self._image.tile[0][3]]

        self._min_side = min(self.imwidth, self.imheight)

        # Image Pyramid
        if self._huge:
            self._pyramid = [self.smaller()]
        else:
            self._pyramid = [Image.fromarray(self.img)]

        # Set ratio coefficeint for pyramid
        if self._huge:
            self._ratio = max(self.imwidth, self.imheight) / self._huge_size
        else:
            self._ratio = 1.0

        self._curr_img = 0  # The current image from the pyramid
        self._scale = self.imscale * self._ratio
        self._reduction = 2  # Reduction degree of pyramid

        w, h, = self._pyramid[-1].size
        while w &gt; 512 and h &gt; 512:
            w /= self._reduction
            h /= self._reduction
            self._pyramid.append(self._pyramid[-1].resize((int(w), int(h)),
                                 self._filter))

        # Put image into rectangle for setting corrdinates
        self.container = self.canvas.create_rectangle((0, 0, self.imwidth,
                                                      self.imheight), width=0)

        self._show_image()

        # Deal with 0 offsets in the y coordinate
        if patch_offset[1] == 0 and patch_offset[0] != 0:
            patch_offset = patch_offset[0], self._prev_offset[1]

        self._prev_offset = patch_offset

        # The anchor point will be moved to (0, 0) in the window
        # We want to account for the patch offset, but not put the current
        # patch right in the corner
        anchorx = -self.canvas.canvasx(0 - (patch_offset[1]/2))
        anchory = -self.canvas.canvasy(0 - (patch_offset[0]/2))

        self.canvas.scan_mark(int(anchorx), int(anchory))
        self.canvas.scan_dragto(0, 0, gain=1)
        self.canvas.focus_set()

        self._show_image()

    def _on_motion(self, event):
        &#34;&#34;&#34;
        Called when the mouse is moved.

        Args:
            event: The mouse event.

        Returns:
            None

        Postconditions:
            The mouse cursor is drawn.
            Previous position is set.
        &#34;&#34;&#34;
        x = self.canvas.canvasx(event.x)
        y = self.canvas.canvasy(event.y)
        pos = (x, y)

        if self._cursor == &#34;brush&#34;:
            self.draw_brush(pos)

        self._previous_position = pos

    def _wheel(self, event):

        super()._wheel(event)

        if self._cursor != &#34;brush&#34;:
            self._main_window.log_zoom_event(self.imscale)

    def _set_cursor(self, event):
        &#34;&#34;&#34;
        Set the cursor to the current specified icon.

        Args:
            event: Event

        Returns:
            None
        &#34;&#34;&#34;
        if self._cursor == &#34;brush&#34;:
            self.canvas.config(cursor=&#34;none&#34;)
            self.draw_brush()
        else:
            self.canvas.config(cursor=self._cursor)
            if self._brush_cursor is not None:
                self.canvas.delete(self._brush_cursor)

    def _default_cursor(self, event):
        &#34;&#34;&#34;
        Set the cursor back to the default.

        Args:
            event: The event

        Returns:
            None
        &#34;&#34;&#34;
        self.canvas.config(cursor=&#34;arrow&#34;)
        self._previous_position = (50, 50)

    def draw_brush(self, pos=None):
        &#34;&#34;&#34;
        Draw the paintbrush cursor

        Args:
            pos: The position to draw the brush at.  The default value is None.

        Returns:
            None

        Postcondition:
            The brush is drawn on the canvas/
        &#34;&#34;&#34;
        if self._brush_cursor is not None:
            self.canvas.delete(self._brush_cursor)

        if self._brush_radius is None:
            self._brush_radius = 15

        if pos is None:
            pos = self._previous_position

        x_max = pos[0] + (self._brush_radius * self._coord_scale)
        x_min = pos[0] - (self._brush_radius * self._coord_scale)
        y_max = pos[1] + (self._brush_radius * self._coord_scale)
        y_min = pos[1] - (self._brush_radius * self._coord_scale)

        self._brush_cursor = self.canvas.create_oval(x_max, y_max, x_min,
                                                     y_min,
                                                     outline=&#39;white&#39;,
                                                     tag=&#39;brush&#39;)

    def _move_from(self, event):
        &#34;&#34;&#34;
        Mark the position of the canvas to move from using scanning.

        Args:
            event: The mouse event

        Returns:
            None

        Postconditions:
            The canvas will have a scan mark at the event position.
        &#34;&#34;&#34;
        if self._cursor != &#34;brush&#34;:
            self.canvas.scan_mark(event.x, event.y)

        log_pos = self._get_container_relative_coords(event.x, event.y)
        self._main_window.log_mouse_event(log_pos, &#34;click&#34;, &#34;left_mouse&#34;)

        self._drag_start = event.x, event.y

    def _right_click(self, event):
        &#34;&#34;&#34;
        For dragging with right mouse button.

        Args:
            event: The mouse event.

        Returns:
            None
        &#34;&#34;&#34;
        self.canvas.scan_mark(event.x, event.y)

        log_pos = self._get_container_relative_coords(event.x, event.y)

        self._main_window.log_mouse_event(log_pos, &#34;click&#34;, &#34;right_mouse&#34;)

    def _on_click_release(self, event):
        &#34;&#34;&#34;
        Called when the left mouse button is released.

        Args:
            event: The mouse event.

        Returns:
            None
        &#34;&#34;&#34;

        if self._dragged:
            self._dragged = False
            return

        pos = self._get_container_relative_coords(event.x, event.y)
        # pos = self.canvas.canvasx(event.x), self.canvas.canvasy(event.y)

        # container_coords = self.canvas.coords(self.container)
        # pos = pos[0] - container_coords[0], pos[1] - container_coords[1]

        # pos = pos[0] / self._coord_scale, pos[1] / self._coord_scale
        self._main_window.on_canvas_click(pos)

        self._main_window.log_mouse_event(pos, &#34;release&#34;, &#34;left_mouse&#34;)

    def _get_container_relative_coords(self, x, y):

        pos = self.canvas.canvasx(x), self.canvas.canvasy(y)

        container_coords = self.canvas.coords(self.container)
        pos = pos[0] - container_coords[0], pos[1] - container_coords[1]

        pos = pos[0] / self._coord_scale, pos[1] / self._coord_scale

        return pos

    def _move_to(self, event):
        &#34;&#34;&#34;
        Move the canvas to the event position.

        Args:
            event: The mouse event.

        Returns:
            None

        Postconditions:
            The canvas is moved to the event position.
        &#34;&#34;&#34;
        self._dragged = True

        if self._drag_id == &#39;&#39;:
            self._logger.debug(&#34;Drag start&#34;)
        else:
            self._main_window._master.after_cancel(self._drag_id)

        self._drag_id = self._main_window._master.\
            after(300, self._stop_dragging)

        if self._cursor != &#34;brush&#34;:

            self.canvas.scan_dragto(event.x, event.y, gain=1)

        if self._cursor == &#34;brush&#34;:

            pos = self.canvas.canvasx(event.x), self.canvas.canvasy(event.y)
            self._previous_position = pos
            container_coords = self.canvas.coords(self.container)
            pos = pos[0] - container_coords[0], pos[1] - container_coords[1]
            pos = pos[0] / self._coord_scale, pos[1] / self._coord_scale

            self._main_window.on_canvas_drag(pos, drag_id=self._unique_drag_id)

            brush_pos = (self.canvas.canvasx(event.x),
                         self.canvas.canvasy(event.y))

            self.draw_brush(brush_pos)

        self._show_image()  # zoom tile and show it on the canvas
        self._drag_end = event.x, event.y

    def _stop_dragging(self):
        self._drag_id = &#39;&#39;
        self._unique_drag_id += 1

        start_pos = self._get_container_relative_coords(self._drag_start[0],
                                                        self._drag_start[1])

        end_pos = self._get_container_relative_coords(self._drag_end[0],
                                                      self._drag_end[1])

        if self._is_right_drag or self._cursor != &#39;brush&#39;:

            self._main_window.log_drag_event(&#34;pan&#34;, start_pos, end_pos)
        else:
            self._main_window.log_drag_event(&#34;brush&#34;, start_pos, end_pos)

        self._id_right_drag = False

    def _right_drag(self, event):
        &#34;&#34;&#34;
        Drag with the right mouse button.

        Args:
            event: The mouse event.

        Returns:
            None
        &#34;&#34;&#34;
        if self._drag_id == &#39;&#39;:
            self._logger.debug(&#34;Drag start&#34;)
        else:
            self._main_window._master.after_cancel(self._drag_id)

        self._drag_id = self._main_window._master.\
            after(300, self._stop_dragging)

        self.canvas.scan_dragto(event.x, event.y, gain=1)

        self._show_image()
        self._is_right_drag = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas">ScrollableImageCanvas</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="friendly_ground_truth.view.fgt_canvas.FGTCanvas.brush_radius"><code class="name">var <span class="ident">brush_radius</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def brush_radius(self):
    return self._brush_radius</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.FGTCanvas.cursor"><code class="name">var <span class="ident">cursor</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cursor(self):
    return self._cursor</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.view.fgt_canvas.FGTCanvas.draw_brush"><code class="name flex">
<span>def <span class="ident">draw_brush</span></span>(<span>self, pos=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the paintbrush cursor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong></dt>
<dd>The position to draw the brush at.
The default value is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postcondition">Postcondition</h2>
<p>The brush is drawn on the canvas/</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_brush(self, pos=None):
    &#34;&#34;&#34;
    Draw the paintbrush cursor

    Args:
        pos: The position to draw the brush at.  The default value is None.

    Returns:
        None

    Postcondition:
        The brush is drawn on the canvas/
    &#34;&#34;&#34;
    if self._brush_cursor is not None:
        self.canvas.delete(self._brush_cursor)

    if self._brush_radius is None:
        self._brush_radius = 15

    if pos is None:
        pos = self._previous_position

    x_max = pos[0] + (self._brush_radius * self._coord_scale)
    x_min = pos[0] - (self._brush_radius * self._coord_scale)
    y_max = pos[1] + (self._brush_radius * self._coord_scale)
    y_min = pos[1] - (self._brush_radius * self._coord_scale)

    self._brush_cursor = self.canvas.create_oval(x_max, y_max, x_min,
                                                 y_min,
                                                 outline=&#39;white&#39;,
                                                 tag=&#39;brush&#39;)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.FGTCanvas.new_image"><code class="name flex">
<span>def <span class="ident">new_image</span></span>(<span>self, image, patch_offset=(0, 0))</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the image and all properties of the image on the canvas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>The image, a numpy array.</dd>
<dt><strong><code>patch_offset</code></strong></dt>
<dd>The offset of the current patch within the image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_image(self, image, patch_offset=(0, 0)):
    &#34;&#34;&#34;
    Reset the image and all properties of the image on the canvas.

    Args:
        image: The image, a numpy array.
        patch_offset: The offset of the current patch within the image

    Returns:
        None
    &#34;&#34;&#34;
    self.imscale = 1.0

    self.canvas.delete(&#34;all&#34;)
    self.img = image

    with warnings.catch_warnings():
        warnings.simplefilter(&#39;ignore&#39;)
        self._image = Image.fromarray(self.img)

    self.imwidth, self.imheight = self._image.size

    if (self.imwidth * self.imheight &gt; self._huge_size * self._huge_size
       and self._image.tile[0][0] == &#39;raw&#39;):

        self._huge = True
        self._offset = self._image.tile[0][2]
        self._tile = [self._image.tile[0][0],
                      [0, 0, self.imwidth, 0],
                      self._offset,
                      self._image.tile[0][3]]

    self._min_side = min(self.imwidth, self.imheight)

    # Image Pyramid
    if self._huge:
        self._pyramid = [self.smaller()]
    else:
        self._pyramid = [Image.fromarray(self.img)]

    # Set ratio coefficeint for pyramid
    if self._huge:
        self._ratio = max(self.imwidth, self.imheight) / self._huge_size
    else:
        self._ratio = 1.0

    self._curr_img = 0  # The current image from the pyramid
    self._scale = self.imscale * self._ratio
    self._reduction = 2  # Reduction degree of pyramid

    w, h, = self._pyramid[-1].size
    while w &gt; 512 and h &gt; 512:
        w /= self._reduction
        h /= self._reduction
        self._pyramid.append(self._pyramid[-1].resize((int(w), int(h)),
                             self._filter))

    # Put image into rectangle for setting corrdinates
    self.container = self.canvas.create_rectangle((0, 0, self.imwidth,
                                                  self.imheight), width=0)

    self._show_image()

    # Deal with 0 offsets in the y coordinate
    if patch_offset[1] == 0 and patch_offset[0] != 0:
        patch_offset = patch_offset[0], self._prev_offset[1]

    self._prev_offset = patch_offset

    # The anchor point will be moved to (0, 0) in the window
    # We want to account for the patch offset, but not put the current
    # patch right in the corner
    anchorx = -self.canvas.canvasx(0 - (patch_offset[1]/2))
    anchory = -self.canvas.canvasy(0 - (patch_offset[0]/2))

    self.canvas.scan_mark(int(anchorx), int(anchory))
    self.canvas.scan_dragto(0, 0, gain=1)
    self.canvas.focus_set()

    self._show_image()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas">ScrollableImageCanvas</a></b></code>:
<ul class="hlist">
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.crop" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.crop">crop</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.destroy" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.destroy">destroy</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.grid" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.grid">grid</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.outside" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.outside">outside</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.pack" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.pack">pack</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.place" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.place">place</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.redraw_figures" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.redraw_figures">redraw_figures</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.smaller" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.smaller">smaller</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.PatchNavCanvas"><code class="flex name class">
<span>class <span class="ident">PatchNavCanvas</span></span>
<span>(</span><span>placeholder, img, main_window, style)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PatchNavCanvas(ScrollableImageCanvas):

    def __init__(self, placeholder, img, main_window, style):

        self._logger = logging.getLogger(&#39;friendly_gt.view.FGTCanvas&#39;)

        super(PatchNavCanvas, self).__init__(placeholder, img, main_window,
                                             style)

        borderwidth = self._style.lookup(&#34;Preview.TFrame&#34;, &#39;borderwidth&#39;)

        relief = self._style.lookup(&#34;Preview.TFrame&#34;, &#39;relief&#39;)

        self.canvas.config(borderwidth=borderwidth, relief=relief)

        self.canvas.bind(&#34;&lt;ButtonRelease-1&gt;&#34;, self._on_click_release)

        self._dragged = False

    def _on_click_release(self, event):
        &#34;&#34;&#34;
        Called when the left mouse button is released.

        Args:
            event: The mouse event.

        Returns:
            None
        &#34;&#34;&#34;

        if self._dragged:
            self._dragged = False
            return

        pos = self.canvas.canvasx(event.x), self.canvas.canvasy(event.y)

        container_coords = self.canvas.coords(self.container)
        pos = pos[0] - container_coords[0], pos[1] - container_coords[1]

        pos = pos[0] / self._coord_scale, pos[1] / self._coord_scale

        self._main_window.navigate_to_patch(pos)

    def set_image(self, image):

        self.img = image
        self._image = Image.fromarray(image)

        pyramid_index = max(0, self._curr_img)

        old_img = self._pyramid[pyramid_index]

        new_image = self._image.resize(old_img.size, self._filter)

        self._pyramid[pyramid_index] = new_image

        self._show_image()

        t = threading.Thread(target=self.recompute_pyramid, name=&#34;pyramid&#34;)
        t.daemon = True
        t.start()

    def new_image(self, image, patch_offset=(0, 0)):
        &#34;&#34;&#34;
        Reset the image and all properties of the image on the canvas.

        Args:
            image: The image, a numpy array.
            patch_offset: The offset of the current patch within the image

        Returns:
            None
        &#34;&#34;&#34;
        self.imscale = 1.0

        self.canvas.delete(&#34;all&#34;)
        self.img = image

        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;)
            self._image = Image.fromarray(self.img)

        self.imwidth, self.imheight = self._image.size

        if (self.imwidth * self.imheight &gt; self._huge_size * self._huge_size
           and self._image.tile[0][0] == &#39;raw&#39;):

            self._huge = True
            self._offset = self._image.tile[0][2]
            self._tile = [self._image.tile[0][0],
                          [0, 0, self.imwidth, 0],
                          self._offset,
                          self._image.tile[0][3]]

        self._min_side = min(self.imwidth, self.imheight)

        # Image Pyramid
        if self._huge:
            self._pyramid = [self.smaller()]
        else:
            self._pyramid = [Image.fromarray(self.img)]

        # Set ratio coefficeint for pyramid
        if self._huge:
            self._ratio = max(self.imwidth, self.imheight) / self._huge_size
        else:
            self._ratio = 1.0

        self._curr_img = 0  # The current image from the pyramid
        self._scale = self.imscale * self._ratio
        self._reduction = 2  # Reduction degree of pyramid

        w, h, = self._pyramid[-1].size
        while w &gt; 512 and h &gt; 512:
            w /= self._reduction
            h /= self._reduction
            self._pyramid.append(self._pyramid[-1].resize((int(w), int(h)),
                                 self._filter))

        # Put image into rectangle for setting corrdinates
        self.container = self.canvas.create_rectangle((0, 0, self.imwidth,
                                                      self.imheight), width=0)

        self._show_image()

    def recompute_pyramid(self):

        new_pyramid = []
        for img in self._pyramid:
            new_image = self._image.resize(img.size, self._filter)
            new_pyramid.append(new_image)

        self._pyramid = new_pyramid

    def _move_to(self, event):
        &#34;&#34;&#34;
        Move the canvas to the event position.

        Args:
            event: The mouse event.

        Returns:
            None

        Postconditions:
            The canvas is moved to the event position.
        &#34;&#34;&#34;
        self._dragged = True

        super()._move_to(event)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas">ScrollableImageCanvas</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.view.fgt_canvas.PatchNavCanvas.new_image"><code class="name flex">
<span>def <span class="ident">new_image</span></span>(<span>self, image, patch_offset=(0, 0))</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the image and all properties of the image on the canvas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>The image, a numpy array.</dd>
<dt><strong><code>patch_offset</code></strong></dt>
<dd>The offset of the current patch within the image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_image(self, image, patch_offset=(0, 0)):
    &#34;&#34;&#34;
    Reset the image and all properties of the image on the canvas.

    Args:
        image: The image, a numpy array.
        patch_offset: The offset of the current patch within the image

    Returns:
        None
    &#34;&#34;&#34;
    self.imscale = 1.0

    self.canvas.delete(&#34;all&#34;)
    self.img = image

    with warnings.catch_warnings():
        warnings.simplefilter(&#39;ignore&#39;)
        self._image = Image.fromarray(self.img)

    self.imwidth, self.imheight = self._image.size

    if (self.imwidth * self.imheight &gt; self._huge_size * self._huge_size
       and self._image.tile[0][0] == &#39;raw&#39;):

        self._huge = True
        self._offset = self._image.tile[0][2]
        self._tile = [self._image.tile[0][0],
                      [0, 0, self.imwidth, 0],
                      self._offset,
                      self._image.tile[0][3]]

    self._min_side = min(self.imwidth, self.imheight)

    # Image Pyramid
    if self._huge:
        self._pyramid = [self.smaller()]
    else:
        self._pyramid = [Image.fromarray(self.img)]

    # Set ratio coefficeint for pyramid
    if self._huge:
        self._ratio = max(self.imwidth, self.imheight) / self._huge_size
    else:
        self._ratio = 1.0

    self._curr_img = 0  # The current image from the pyramid
    self._scale = self.imscale * self._ratio
    self._reduction = 2  # Reduction degree of pyramid

    w, h, = self._pyramid[-1].size
    while w &gt; 512 and h &gt; 512:
        w /= self._reduction
        h /= self._reduction
        self._pyramid.append(self._pyramid[-1].resize((int(w), int(h)),
                             self._filter))

    # Put image into rectangle for setting corrdinates
    self.container = self.canvas.create_rectangle((0, 0, self.imwidth,
                                                  self.imheight), width=0)

    self._show_image()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.PatchNavCanvas.recompute_pyramid"><code class="name flex">
<span>def <span class="ident">recompute_pyramid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recompute_pyramid(self):

    new_pyramid = []
    for img in self._pyramid:
        new_image = self._image.resize(img.size, self._filter)
        new_pyramid.append(new_image)

    self._pyramid = new_pyramid</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.PatchNavCanvas.set_image"><code class="name flex">
<span>def <span class="ident">set_image</span></span>(<span>self, image)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_image(self, image):

    self.img = image
    self._image = Image.fromarray(image)

    pyramid_index = max(0, self._curr_img)

    old_img = self._pyramid[pyramid_index]

    new_image = self._image.resize(old_img.size, self._filter)

    self._pyramid[pyramid_index] = new_image

    self._show_image()

    t = threading.Thread(target=self.recompute_pyramid, name=&#34;pyramid&#34;)
    t.daemon = True
    t.start()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas">ScrollableImageCanvas</a></b></code>:
<ul class="hlist">
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.crop" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.crop">crop</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.destroy" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.destroy">destroy</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.grid" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.grid">grid</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.outside" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.outside">outside</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.pack" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.pack">pack</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.place" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.place">place</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.redraw_figures" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.redraw_figures">redraw_figures</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.smaller" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.smaller">smaller</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas"><code class="flex name class">
<span>class <span class="ident">ScrollableImageCanvas</span></span>
<span>(</span><span>placeholder, img, main_window, style)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScrollableImageCanvas:

    def __init__(self, placeholder, img, main_window, style):

        self._logger = logging.\
            getLogger(&#39;friendly_gt.view.ScrollableImageCanvas&#39;)

        self._style = style

        self.imscale = 1.0  # Scale of the image

        self._main_window = main_window

        self._delta = 1.3  # Zoom magnitude
        self._filter = Image.ANTIALIAS
        self._previous_state = 0  # The previous state of the keyboard
        self._imframe = ttk.Frame(placeholder)

        self.img = img

        # Scrollbars
        hbar = AutoScrollbar(self._imframe, orient=&#39;horizontal&#39;)
        vbar = AutoScrollbar(self._imframe, orient=&#39;vertical&#39;)

        hbar.grid(row=1, column=0, sticky=&#39;we&#39;)
        vbar.grid(row=0, column=1, sticky=&#39;ns&#39;)

        # Create the canvas
        self.canvas = tk.Canvas(self._imframe, highlightthickness=0,
                                xscrollcommand=hbar.set,
                                yscrollcommand=vbar.set)

        self.canvas.grid(row=0, column=0, sticky=&#39;nswe&#39;)

        background = self._style.lookup(&#34;Canvas.TFrame&#34;, &#39;background&#39;)

        self.canvas.config(background=background)
        self.canvas.update()  # Make sure the canvas updates

        self._orig_canvas_x = self.canvas.xview()[0]
        self._orig_canvas_y = self.canvas.yview()[0]

        hbar.configure(command=self._scroll_x)
        vbar.configure(command=self._scroll_y)

        # Bind events to the canvas
        # When the canvas is resized
        self.canvas.bind(&#39;&lt;Configure&gt;&#39;, lambda event: self._show_image())
        # Remember the canvas position
        self.canvas.bind(&#39;&lt;ButtonPress-1&gt;&#39;, self._move_from)

        # Move the canvas
        self.canvas.bind(&#39;&lt;B1-Motion&gt;&#39;, self._move_to)

        # Zoom for Windows and MacOs
        self.canvas.bind(&#39;&lt;MouseWheel&gt;&#39;, self._wheel)
        # Zoom for Linux, scroll down
        self.canvas.bind(&#39;&lt;Button-5&gt;&#39;, self._wheel)
        # Zoom for Linux, scroll up
        self.canvas.bind(&#39;&lt;Button-4&gt;&#39;, self._wheel)

        # Deal with keystrokes in idle mode
        self.canvas.bind(&#39;&lt;Key&gt;&#39;, lambda event:
                         self.canvas.after_idle(self._keystroke, event))

        # Decide if the image is too big
        self._huge = False
        self._huge_size = 14000
        self._band_width = 1024

        Image.MAX_IMAGE_PIXELS = 1000000000

        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;)
            self._image = Image.fromarray(self.img)

        self.imwidth, self.imheight = self._image.size

        if (self.imwidth * self.imheight &gt; self._huge_size * self._huge_size
           and self._image.tile[0][0] == &#39;raw&#39;):

            self._huge = True
            self._offset = self._image.tile[0][2]
            self._tile = [self._image.tile[0][0],
                          [0, 0, self.imwidth, 0],
                          self._offset,
                          self._image.tile[0][3]]

        self._min_side = min(self.imwidth, self.imheight)

        # Image Pyramid
        if self._huge:
            self._pyramid = [self.smaller()]
        else:
            self._pyramid = [Image.fromarray(self.img)]

        # Set ratio coefficeint for pyramid
        if self._huge:
            self._ratio = max(self.imwidth, self.imheight) / self._huge_size
        else:
            self._ratio = 1.0

        self._curr_img = 0  # The current image from the pyramid
        self._scale = self.imscale * self._ratio
        self._reduction = 2  # Reduction degree of pyramid

        w, h, = self._pyramid[-1].size
        while w &gt; 512 and h &gt; 512:
            w /= self._reduction
            h /= self._reduction
            self._pyramid.append(self._pyramid[-1].resize((int(w), int(h)),
                                 self._filter))

        # Put image into rectangle for setting corrdinates
        self.container = self.canvas.create_rectangle((0, 0, self.imwidth,
                                                      self.imheight), width=0)

        self._show_image()
        self.canvas.focus_set()

    def set_image(self, img):
        self.img = img
        self._show_image()
        self.canvas.focus_set()

    def set_theme(self, style):
        background = self._style.lookup(&#34;Canvas.TFrame&#34;, &#39;background&#39;)

        self.canvas.config(background=background)

    def smaller(self):
        &#34;&#34;&#34;
        Resize the image to be smaller.


        Returns:
            A resized PIL image
        &#34;&#34;&#34;
        w1, h1 = float(self.imwidth), float(self.imheight)
        w2, h2 = float(self._huge_size), float(self._huge_size)

        aspect_ratio1 = w1 / h1
        aspect_ratio2 = w2 / h2

        if aspect_ratio1 == aspect_ratio2:
            image = Image.new(&#39;RGB&#39;, (int(w2), int(h2)))
            k = h2 / h1  # Compression ratio
            w = int(w2)  # Band length
        elif aspect_ratio1 &gt; aspect_ratio2:
            image = Image.new(&#39;RGB&#39;, (int(w2), int(w2 / aspect_ratio1)))
            k = h2 / w1
            w = int(w2)
        else:  # aspect_ratio1 &lt; aspect_ratio2
            image = Image.new(&#39;RGB&#39;, (int(h2 * aspect_ratio1), int(h2)))
            k = h2 / h1
            w = int(h2 * aspect_ratio1)

        i, j, _ = 0, 1, round(0.5 + self.imheight / self._band_width)

        while i &lt; self.imheight:
            # Width of the tile band
            band = min(self._band_width, self.imheight - i)

            self._tile[1][3] = band

            # Tile offset (3 bytes per pixel)
            self._tile[2] = self._offset + self.imwidth * i * 3
            self._image.close()
            self._image = Image.fromarray(self.img)
            self._image.size = (self.imwidth * band)
            self._image.tile = [self._tile]

            cropped = self._image.crop((0, 0, self.imwidth, band))  # crop
            image.paste(cropped.resize((w, int(band * k)+1), self._filer), (0,
                        int(i * k)))

            i += band
            j += 1

        return image

    def redraw_figures(self):
        &#34;&#34;&#34;
        Dummy function for redrawing in children classes


        Returns:
            None
        &#34;&#34;&#34;
        pass

    def grid(self, **kw):
        &#34;&#34;&#34;
        Put the Canvas widget on the parent widget.

        Args:
            **kw: Kwargs

        Returns:
            None
        &#34;&#34;&#34;
        self._imframe.grid(**kw)  # Put the canvas on the grid
        self._imframe.grid(sticky=&#39;nswe&#39;)  # Make frame sticky
        self._imframe.rowconfigure(0, weight=1)  # Make canvas expandable
        self._imframe.columnconfigure(0, weight=1)

    def pack(self, **kw):
        &#34;&#34;&#34;
        Cannot use pack.

        Args:
            **kw: Kwargs

        Returns:
            None

        Raises:
            Exception, you can&#39;t use the pack function.
        &#34;&#34;&#34;
        raise Exception(&#39;Cannot use pack with the widget &#39; +
                        self._class_._name_)

    def place(self, **kw):
        &#34;&#34;&#34;
        The place method of the tkinter widget.

        Args:
            **kw: kwargs

        Returns:
            None

        Raises:
            An exception, as this cannot be used with this widget.
        &#34;&#34;&#34;
        raise Exception(&#39;Cannot use place with the widget &#39; +
                        self._class_._name_)

    # noinspection PyUnusedLocal
    def _scroll_x(self, *args, **kwargs):
        &#34;&#34;&#34;
        Scroll in the x direction.

        Args:
            *args: args
            **kwargs: kwargs

        Returns:
            None

        Postconditions:
            The canvas is scrolled horizontally.
        &#34;&#34;&#34;
        self.canvas.xview(*args)  # scroll horizontally
        self._show_image()  # redraw the image

    # noinspection PyUnusedLocal
    def _scroll_y(self, *args, **kwargs):
        &#34;&#34;&#34;
        Scroll in the y direction

        Args:
            *args: args
            **kwargs: kwargs

        Returns:
            None

        Postconditions:
            The canvas is scrolled vertically.
        &#34;&#34;&#34;
        self.canvas.yview(*args)  # scroll vertically
        self._show_image()  # redraw the image

    def _show_image(self):
        &#34;&#34;&#34;
        Display the current image


        Returns:
            None

        Postconditions:
            The image is drawn on the canvas.
        &#34;&#34;&#34;
        box_image = self.canvas.coords(self.container)  # get image area
        box_canvas = (self.canvas.canvasx(0),  # get visible area of the canvas
                      self.canvas.canvasy(0),
                      self.canvas.canvasx(self.canvas.winfo_width()),
                      self.canvas.canvasy(self.canvas.winfo_height()))

        # convert to integer or it will not work properly
        box_img_int = tuple(map(int, box_image))  # Get scroll region box

        box_img_width = box_img_int[2] - box_img_int[0]

        xscale = box_img_width/self.img.shape[1]

        self._coord_scale = xscale

        box_scroll = [min(box_img_int[0], box_canvas[0]),
                      min(box_img_int[1], box_canvas[1]),
                      max(box_img_int[2], box_canvas[2]),
                      max(box_img_int[3], box_canvas[3])]

        # Horizontal part of the image is in the visible area
        if box_scroll[0] == box_canvas[0] and box_scroll[2] == box_canvas[2]:
            box_scroll[0] = box_img_int[0]
            box_scroll[2] = box_img_int[2]
        # Vertical part of the image is in the visible area
        if box_scroll[1] == box_canvas[1] and box_scroll[3] == box_canvas[3]:
            box_scroll[1] = box_img_int[1]
            box_scroll[3] = box_img_int[3]
        # Convert scroll region to tuple and to integer
        # set scroll region
        self.canvas.configure(scrollregion=tuple(map(int, box_scroll)))

        # get coordinates (x1,y1,x2,y2) of the image tile
        x1 = max(box_canvas[0] - box_image[0], 0)
        y1 = max(box_canvas[1] - box_image[1], 0)
        x2 = min(box_canvas[2], box_image[2]) - box_image[0]
        y2 = min(box_canvas[3], box_image[3]) - box_image[1]

        # show image if it in the visible area
        if int(x2 - x1) &gt; 0 and int(y2 - y1) &gt; 0:
            if self._huge and self._curr_img &lt; 0:  # show huge image
                h = int((y2 - y1) / self.imscale)  # height of the tile band
                self._tile[1][3] = h  # set the tile band height
                self._tile[2] = (self._offset + self.imwidth *
                                 int(y1 / self.imscale) * 3)
                self._image.close()
                self._image = Image.open(self.path)  # reopen / reset image
                # set size of the tile band
                self._image.size = (self.imwidth, h)
                self._image.tile = [self._tile]
                image = self._image.crop((int(x1 / self.imscale), 0,
                                          int(x2 / self.imscale), h))
            else:  # show normal image
                # crop current img from pyramid
                image = self._pyramid[max(0, self._curr_img)].crop(
                                    (int(x1 / self._scale),
                                     int(y1 / self._scale),
                                     int(x2 / self._scale),
                                     int(y2 / self._scale)))
            #
            imagetk = ImageTk.PhotoImage(image.resize((int(x2 - x1),
                                         int(y2 - y1)), self._filter))

            imageid = self.canvas.create_image(max(box_canvas[0],
                                               box_img_int[0]),
                                               max(box_canvas[1],
                                               box_img_int[1]),
                                               anchor=&#39;nw&#39;, image=imagetk)
            self.canvas.lower(imageid)  # set image into background
            # keep an extra reference to prevent garbage-collection
            self.canvas.imagetk = imagetk
            self._image_id = imageid

    def _move_from(self, event):
        &#34;&#34;&#34;
        Mark the position of the canvas to move from using scanning.

        Args:
            event: The mouse event

        Returns:
            None

        Postconditions:
            The canvas will have a scan mark at the event position.
        &#34;&#34;&#34;
        self.canvas.scan_mark(event.x, event.y)

    def _move_to(self, event):
        &#34;&#34;&#34;
        Move the canvas to the event position.

        Args:
            event: The mouse event.

        Returns:
            None

        Postconditions:
            The canvas is moved to the event position.
        &#34;&#34;&#34;
        self.canvas.scan_dragto(event.x, event.y, gain=1)

        self._show_image()  # zoom tile and show it on the canvas

    def outside(self, x, y):
        &#34;&#34;&#34;
        Check it the input point is inside the image area.

        Args:
            x: The x coordinate
            y: The y coordinate

        Returns:
            True if the point is inside the image.
            False if the point is outside the image.
        &#34;&#34;&#34;
        bbox = self.canvas.coords(self.container)  # get image area
        if bbox[0] &lt; x &lt; bbox[2] and bbox[1] &lt; y &lt; bbox[3]:
            return False  # point (x,y) is inside the image area
        else:
            return True  # point (x,y) is outside the image area

    def set_zoom(self, factor):
        x, y = 0, 0
        scale = 1.0
        if factor &lt; 0:
            if round(self._min_side * self.imscale) &lt; 30:
                return  # image is less than 30 pixels
            self.imscale /= (self._delta * (-factor))
            scale /= (self._delta * (-factor))

        if factor &gt; 0:
            i = min(self.canvas.winfo_width(), self.canvas.winfo_height()) &gt;&gt; 1
            if i &lt; self.imscale:
                return  # 1 pixel is bigger than the visible area
            self.imscale *= self._delta
            scale *= self._delta

        # Take appropriate image from the pyramid
        k = self.imscale * self._ratio  # temporary coefficient
        self._curr_img = min((-1) * int(math.log(k, self._reduction)),
                             len(self._pyramid) - 1)
        self._scale = k * math.pow(self._reduction, max(0, self._curr_img))
        #
        self.canvas.scale(&#39;all&#39;, x, y, scale, scale)  # rescale all objects
        # Redraw some figures before showing image on the screen
        self.redraw_figures()  # method for child classes
        self._show_image()

    def _wheel(self, event):
        &#34;&#34;&#34;
        Called when the mouse wheel is scrolled.

        Args:
            event: The mouse event.

        Returns:
            None

        Postconditions:
            The image on the canvas is zoomed.
        &#34;&#34;&#34;
        # get coordinates of the event on the canvas
        x = self.canvas.canvasx(event.x)
        y = self.canvas.canvasy(event.y)
        if self.outside(x, y):
            return  # zoom only inside image area

        # Don&#39;t scroll if control is down
        if event.state - self._previous_state == 4:
            return

        scale = 1.0
        # Respond to Linux (event.num) or Windows (event.delta) wheel event
        if event.num == 5 or event.delta == -120:  # scroll down, smaller
            if round(self._min_side * self.imscale) &lt; 30:
                return  # image is less than 30 pixels
            self.imscale /= self._delta
            scale /= self._delta
        if event.num == 4 or event.delta == 120:  # scroll up, bigger
            i = min(self.canvas.winfo_width(), self.canvas.winfo_height()) &gt;&gt; 1
            if i &lt; self.imscale:
                return  # 1 pixel is bigger than the visible area
            self.imscale *= self._delta
            scale *= self._delta
        # Take appropriate image from the pyramid
        k = self.imscale * self._ratio  # temporary coefficient
        self._curr_img = min((-1) * int(math.log(k, self._reduction)),
                             len(self._pyramid) - 1)
        self._scale = k * math.pow(self._reduction, max(0, self._curr_img))
        #
        self.canvas.scale(&#39;all&#39;, x, y, scale, scale)  # rescale all objects
        # Redraw some figures before showing image on the screen
        self.redraw_figures()  # method for child classes
        self._show_image()

    def _keystroke(self, event):
        &#34;&#34;&#34;
        Called when the keybord is used.

        Args:
            event: The keyboard event.

        Returns:
            None

        Postconditions:
            The canvas is modified according to the key pressed.
        &#34;&#34;&#34;
        # means that the Control key is pressed
        if event.state - self._previous_state == 4:
            pass  # do nothing if Control key is pressed
        else:
            # remember the last keystroke state
            self._previous_state = event.state

    def crop(self, bbox):
        &#34;&#34;&#34;
        Crop the image using the given bounding box.

        Args:
            bbox: The bounding box, a list

        Returns:
            The cropped image.
        &#34;&#34;&#34;
        if self._huge:  # image is huge and not totally in RAM
            band = bbox[3] - bbox[1]  # width of the tile band
            self._tile[1][3] = band  # set the tile height
            # set offset of the band
            self._tile[2] = self._offset + self.imwidth * bbox[1] * 3
            self._image.close()
            self._image = Image.open(self.path)  # reopen / reset image
            # set size of the tile band
            self._image.size = (self.imwidth, band)
            self._image.tile = [self._tile]
            return self._image.crop((bbox[0], 0, bbox[2], band))
        else:  # image is totally in RAM
            return self._pyramid[0].crop(bbox)

    def destroy(self):
        &#34;&#34;&#34; ImageFrame destructor &#34;&#34;&#34;
        self._image.close()
        map(lambda i: i.close, self._pyramid)  # close all pyramid images
        del self._pyramid[:]  # delete pyramid list
        del self._pyramid  # delete pyramid variable
        self.canvas.destroy()
        self._imframe.destroy()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="friendly_ground_truth.view.fgt_canvas.FGTCanvas" href="#friendly_ground_truth.view.fgt_canvas.FGTCanvas">FGTCanvas</a></li>
<li><a title="friendly_ground_truth.view.fgt_canvas.PatchNavCanvas" href="#friendly_ground_truth.view.fgt_canvas.PatchNavCanvas">PatchNavCanvas</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>self, bbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop the image using the given bounding box.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bbox</code></strong></dt>
<dd>The bounding box, a list</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The cropped image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop(self, bbox):
    &#34;&#34;&#34;
    Crop the image using the given bounding box.

    Args:
        bbox: The bounding box, a list

    Returns:
        The cropped image.
    &#34;&#34;&#34;
    if self._huge:  # image is huge and not totally in RAM
        band = bbox[3] - bbox[1]  # width of the tile band
        self._tile[1][3] = band  # set the tile height
        # set offset of the band
        self._tile[2] = self._offset + self.imwidth * bbox[1] * 3
        self._image.close()
        self._image = Image.open(self.path)  # reopen / reset image
        # set size of the tile band
        self._image.size = (self.imwidth, band)
        self._image.tile = [self._tile]
        return self._image.crop((bbox[0], 0, bbox[2], band))
    else:  # image is totally in RAM
        return self._pyramid[0].crop(bbox)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ImageFrame destructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34; ImageFrame destructor &#34;&#34;&#34;
    self._image.close()
    map(lambda i: i.close, self._pyramid)  # close all pyramid images
    del self._pyramid[:]  # delete pyramid list
    del self._pyramid  # delete pyramid variable
    self.canvas.destroy()
    self._imframe.destroy()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.grid"><code class="name flex">
<span>def <span class="ident">grid</span></span>(<span>self, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>Put the Canvas widget on the parent widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kw</code></strong></dt>
<dd>Kwargs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grid(self, **kw):
    &#34;&#34;&#34;
    Put the Canvas widget on the parent widget.

    Args:
        **kw: Kwargs

    Returns:
        None
    &#34;&#34;&#34;
    self._imframe.grid(**kw)  # Put the canvas on the grid
    self._imframe.grid(sticky=&#39;nswe&#39;)  # Make frame sticky
    self._imframe.rowconfigure(0, weight=1)  # Make canvas expandable
    self._imframe.columnconfigure(0, weight=1)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.outside"><code class="name flex">
<span>def <span class="ident">outside</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Check it the input point is inside the image area.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The x coordinate</dd>
<dt><strong><code>y</code></strong></dt>
<dd>The y coordinate</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the point is inside the image.
False if the point is outside the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def outside(self, x, y):
    &#34;&#34;&#34;
    Check it the input point is inside the image area.

    Args:
        x: The x coordinate
        y: The y coordinate

    Returns:
        True if the point is inside the image.
        False if the point is outside the image.
    &#34;&#34;&#34;
    bbox = self.canvas.coords(self.container)  # get image area
    if bbox[0] &lt; x &lt; bbox[2] and bbox[1] &lt; y &lt; bbox[3]:
        return False  # point (x,y) is inside the image area
    else:
        return True  # point (x,y) is outside the image area</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.pack"><code class="name flex">
<span>def <span class="ident">pack</span></span>(<span>self, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>Cannot use pack.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kw</code></strong></dt>
<dd>Kwargs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>Exception, you can't use the pack function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack(self, **kw):
    &#34;&#34;&#34;
    Cannot use pack.

    Args:
        **kw: Kwargs

    Returns:
        None

    Raises:
        Exception, you can&#39;t use the pack function.
    &#34;&#34;&#34;
    raise Exception(&#39;Cannot use pack with the widget &#39; +
                    self._class_._name_)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.place"><code class="name flex">
<span>def <span class="ident">place</span></span>(<span>self, **kw)</span>
</code></dt>
<dd>
<div class="desc"><p>The place method of the tkinter widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kw</code></strong></dt>
<dd>kwargs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>An exception, as this cannot be used with this widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def place(self, **kw):
    &#34;&#34;&#34;
    The place method of the tkinter widget.

    Args:
        **kw: kwargs

    Returns:
        None

    Raises:
        An exception, as this cannot be used with this widget.
    &#34;&#34;&#34;
    raise Exception(&#39;Cannot use place with the widget &#39; +
                    self._class_._name_)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.redraw_figures"><code class="name flex">
<span>def <span class="ident">redraw_figures</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Dummy function for redrawing in children classes</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redraw_figures(self):
    &#34;&#34;&#34;
    Dummy function for redrawing in children classes


    Returns:
        None
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.set_image"><code class="name flex">
<span>def <span class="ident">set_image</span></span>(<span>self, img)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_image(self, img):
    self.img = img
    self._show_image()
    self.canvas.focus_set()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.set_theme"><code class="name flex">
<span>def <span class="ident">set_theme</span></span>(<span>self, style)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_theme(self, style):
    background = self._style.lookup(&#34;Canvas.TFrame&#34;, &#39;background&#39;)

    self.canvas.config(background=background)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.set_zoom"><code class="name flex">
<span>def <span class="ident">set_zoom</span></span>(<span>self, factor)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_zoom(self, factor):
    x, y = 0, 0
    scale = 1.0
    if factor &lt; 0:
        if round(self._min_side * self.imscale) &lt; 30:
            return  # image is less than 30 pixels
        self.imscale /= (self._delta * (-factor))
        scale /= (self._delta * (-factor))

    if factor &gt; 0:
        i = min(self.canvas.winfo_width(), self.canvas.winfo_height()) &gt;&gt; 1
        if i &lt; self.imscale:
            return  # 1 pixel is bigger than the visible area
        self.imscale *= self._delta
        scale *= self._delta

    # Take appropriate image from the pyramid
    k = self.imscale * self._ratio  # temporary coefficient
    self._curr_img = min((-1) * int(math.log(k, self._reduction)),
                         len(self._pyramid) - 1)
    self._scale = k * math.pow(self._reduction, max(0, self._curr_img))
    #
    self.canvas.scale(&#39;all&#39;, x, y, scale, scale)  # rescale all objects
    # Redraw some figures before showing image on the screen
    self.redraw_figures()  # method for child classes
    self._show_image()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.smaller"><code class="name flex">
<span>def <span class="ident">smaller</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resize the image to be smaller.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A resized PIL image</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smaller(self):
    &#34;&#34;&#34;
    Resize the image to be smaller.


    Returns:
        A resized PIL image
    &#34;&#34;&#34;
    w1, h1 = float(self.imwidth), float(self.imheight)
    w2, h2 = float(self._huge_size), float(self._huge_size)

    aspect_ratio1 = w1 / h1
    aspect_ratio2 = w2 / h2

    if aspect_ratio1 == aspect_ratio2:
        image = Image.new(&#39;RGB&#39;, (int(w2), int(h2)))
        k = h2 / h1  # Compression ratio
        w = int(w2)  # Band length
    elif aspect_ratio1 &gt; aspect_ratio2:
        image = Image.new(&#39;RGB&#39;, (int(w2), int(w2 / aspect_ratio1)))
        k = h2 / w1
        w = int(w2)
    else:  # aspect_ratio1 &lt; aspect_ratio2
        image = Image.new(&#39;RGB&#39;, (int(h2 * aspect_ratio1), int(h2)))
        k = h2 / h1
        w = int(h2 * aspect_ratio1)

    i, j, _ = 0, 1, round(0.5 + self.imheight / self._band_width)

    while i &lt; self.imheight:
        # Width of the tile band
        band = min(self._band_width, self.imheight - i)

        self._tile[1][3] = band

        # Tile offset (3 bytes per pixel)
        self._tile[2] = self._offset + self.imwidth * i * 3
        self._image.close()
        self._image = Image.fromarray(self.img)
        self._image.size = (self.imwidth * band)
        self._image.tile = [self._tile]

        cropped = self._image.crop((0, 0, self.imwidth, band))  # crop
        image.paste(cropped.resize((w, int(band * k)+1), self._filer), (0,
                    int(i * k)))

        i += band
        j += 1

    return image</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="friendly_ground_truth.view" href="index.html">friendly_ground_truth.view</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="friendly_ground_truth.view.fgt_canvas.AutoScrollbar" href="#friendly_ground_truth.view.fgt_canvas.AutoScrollbar">AutoScrollbar</a></code></h4>
<ul class="">
<li><code><a title="friendly_ground_truth.view.fgt_canvas.AutoScrollbar.pack" href="#friendly_ground_truth.view.fgt_canvas.AutoScrollbar.pack">pack</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.AutoScrollbar.place" href="#friendly_ground_truth.view.fgt_canvas.AutoScrollbar.place">place</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.AutoScrollbar.set" href="#friendly_ground_truth.view.fgt_canvas.AutoScrollbar.set">set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="friendly_ground_truth.view.fgt_canvas.FGTCanvas" href="#friendly_ground_truth.view.fgt_canvas.FGTCanvas">FGTCanvas</a></code></h4>
<ul class="">
<li><code><a title="friendly_ground_truth.view.fgt_canvas.FGTCanvas.brush_radius" href="#friendly_ground_truth.view.fgt_canvas.FGTCanvas.brush_radius">brush_radius</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.FGTCanvas.cursor" href="#friendly_ground_truth.view.fgt_canvas.FGTCanvas.cursor">cursor</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.FGTCanvas.draw_brush" href="#friendly_ground_truth.view.fgt_canvas.FGTCanvas.draw_brush">draw_brush</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.FGTCanvas.new_image" href="#friendly_ground_truth.view.fgt_canvas.FGTCanvas.new_image">new_image</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="friendly_ground_truth.view.fgt_canvas.PatchNavCanvas" href="#friendly_ground_truth.view.fgt_canvas.PatchNavCanvas">PatchNavCanvas</a></code></h4>
<ul class="">
<li><code><a title="friendly_ground_truth.view.fgt_canvas.PatchNavCanvas.new_image" href="#friendly_ground_truth.view.fgt_canvas.PatchNavCanvas.new_image">new_image</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.PatchNavCanvas.recompute_pyramid" href="#friendly_ground_truth.view.fgt_canvas.PatchNavCanvas.recompute_pyramid">recompute_pyramid</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.PatchNavCanvas.set_image" href="#friendly_ground_truth.view.fgt_canvas.PatchNavCanvas.set_image">set_image</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas">ScrollableImageCanvas</a></code></h4>
<ul class="two-column">
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.crop" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.crop">crop</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.destroy" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.destroy">destroy</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.grid" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.grid">grid</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.outside" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.outside">outside</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.pack" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.pack">pack</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.place" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.place">place</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.redraw_figures" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.redraw_figures">redraw_figures</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.set_image" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.set_image">set_image</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.set_theme" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.set_theme">set_theme</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.set_zoom" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.set_zoom">set_zoom</a></code></li>
<li><code><a title="friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.smaller" href="#friendly_ground_truth.view.fgt_canvas.ScrollableImageCanvas.smaller">smaller</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>