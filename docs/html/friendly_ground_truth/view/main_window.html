<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>friendly_ground_truth.view.main_window API documentation</title>
<meta name="description" content="File Name: main_window.py â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>friendly_ground_truth.view.main_window</code></h1>
</header>
<section id="section-intro">
<p>File Name: main_window.py</p>
<p>Authors: Kyle Seidenthal</p>
<p>Date: 13-05-2020</p>
<p>Description: The main window for the application.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
File Name: main_window.py

Authors: Kyle Seidenthal

Date: 13-05-2020

Description: The main window for the application.

&#34;&#34;&#34;

import tkinter as tk
import base64

import threading

from tkinter import ttk
from io import BytesIO

from PIL import Image
from PIL import ImageTk as itk

from friendly_ground_truth.view.fgt_canvas import FGTCanvas
from friendly_ground_truth.view.info_panel import InfoPanel
from friendly_ground_truth.view.help_dialogs import (AboutDialog,
                                                     KeyboardShortcutDialog)
from friendly_ground_truth.view.preferences_window import PreferencesWindow
from friendly_ground_truth.view.preview_window import (PreviewFrame,
                                                       PreviewWindow)
from functools import partial

import logging
module_logger = logging.getLogger(&#39;friendly_gt.view&#39;)


class MainWindow(ttk.Frame):
    &#34;&#34;&#34;
    The main window for the application.

    Attributes:
        {% An Attribute %}: {% Description %}
    &#34;&#34;&#34;

    def __init__(self, master, controller):
        &#34;&#34;&#34;
        Initialize the main window.

        Args:
            master: The root tkinter process.
            controller: The controller logic

        Returns:
            A main window object.
        &#34;&#34;&#34;

        self._preview_window = None
        self._cur_preview_thread = None

        preferences = controller.load_preferences()

        self._preferences = preferences

        theme = preferences[&#39;theme&#39;]

        if theme == &#39;Light&#39;:
            self._darkmode = False
        elif theme == &#39;Dark&#39;:
            self._darkmode = True

        if self._darkmode:
            from friendly_ground_truth.view import dark_theme

            dark_theme.style.theme_use(&#34;dark_theme&#34;)
            self.style = dark_theme.style

        else:
            from friendly_ground_truth.view import light_theme
            light_theme.style.theme_use(&#34;light_theme&#34;)
            self.style = light_theme.style

        ttk.Frame.__init__(self, master=master, style=&#34;Main.TFrame&#34;)

        # --------------------------------------
        # Private Attributes
        # --------------------------------------

        # The parent tkinter object
        self._master = master
        # The controller for this window
        self._controller = controller

        # For logging
        self._logger = logging.getLogger(&#39;friendly_gt.view.MainWindow&#39;)

        # The canvas used to display and interact with images
        self._canvas = None

        # The previous state of the keyboard
        self._previous_state = 0

        # Mappings from tool id to keyboard shortcut
        self._key_mappings = {}
        # Mappings from keyboard shortcut to tool id
        self._reverse_key_mappings = {}

        # Tkinter menu objects
        self._menubar = None
        self._filemenu = None
        self._helpmenu = None

        # Toolbar
        self._toolbar = None
        # id -&gt; button mapping
        self._toolbar_buttons = {}
        # The colour of a default button
        self._orig_button_colour = None
        # The label displaying the path to the current image
        self._image_indicator = None

        self._old_tool_id = None
        # The previous image
        self._old_img = None

        self._old_tool = None
        # --------------------------------------

        self._master.title(&#34;Friendly Ground Truth&#34;)
        self._master.columnconfigure(0, weight=1)

        self._master.grid_rowconfigure(0, weight=0)
        self._master.grid_rowconfigure(1, weight=1)

        self._set_master_theme()

        self._register_key_mappings()

        self._create_menubar()

        # Interactions
        self.bind_all(&#39;&lt;Key&gt;&#39;, self._keystroke)
        # Mousewheel for Windows and Mac
        self.bind_all(&#34;&lt;MouseWheel&gt;&#34;, self._on_mousewheel)

        # Mousewheel for Linux
        self.bind_all(&#34;&lt;Button-5&gt;&#34;, self._on_mousewheel)
        self.bind_all(&#34;&lt;Button-4&gt;&#34;, self._on_mousewheel)

        self._info_panel = InfoPanel(self.master)
        self._info_panel.config(style=&#34;InfoPanel.TFrame&#34;)

        self._info_panel.grid(row=2, column=0, sticky=&#39;ew&#39;, columnspan=2)

        if self._darkmode:
            self._enable_darkmode_buttons()
    # ==========================================================
    # PUBLIC FUNCTIONS
    # ==========================================================

    def create_canvas(self, image):
        &#34;&#34;&#34;
        Create the image canvas.

        Args:
            image: The image, a numpy array.

        Returns:
            None

        Postconditions:
            self._canvas is set
        &#34;&#34;&#34;
        if self._canvas is not None:
            self._canvas.destroy()

        self._canvas = FGTCanvas(self.master, image, self, self.style)
        self._canvas.grid(row=1, column=0, sticky=&#34;NSEW&#34;)

        self._on_preview_setting()

    def set_theme(self, theme):
        &#34;&#34;&#34;
        Set the current theme for the application.

        Args:
            theme: A string.

        Returns:
            None
        &#34;&#34;&#34;

        if theme.lower() == &#39;dark&#39;:
            self._darkmode = True

            from friendly_ground_truth.view import dark_theme

            dark_theme.style.theme_use(&#34;dark_theme&#34;)
            self.style = dark_theme.style

            self._enable_darkmode_buttons()

        elif theme.lower() == &#39;light&#39;:
            self._darkmode = False
            from friendly_ground_truth.view import light_theme

            light_theme.style.theme_use(&#34;light_theme&#34;)
            self.style = light_theme.style

            self._toolbar.destroy()
            self._create_toolbar()

        self._set_menubar_theme()
        self._set_helpmenu_theme()
        self._set_viewmenu_theme()
        self._set_master_theme()
        self._set_filemenu_theme()

        self._canvas.set_theme(self.style)

        if self._preview_window is not None:
            self._preview_window.set_theme(self.style)

    def start_progressbar(self, num_patches):
        &#34;&#34;&#34;
        Start displaying a progressbar.

        Args:
            num_patches: The number of patches that are being loaded.

        Returns:
            None

        Postconditions:
            A progressbar window is opened and initialized
        &#34;&#34;&#34;
        self.progress_popup = tk.Toplevel()
        self.progress_popup.geometry(&#34;100x50+500+400&#34;)

        frame = ttk.Frame(self.progress_popup)

        ttk.Label(frame, text=&#34;Image Loading.&#34;)\
            .grid(row=0, column=0)

        self.load_progress = 0
        self.load_progress_var = tk.DoubleVar()
        self.load_progress_bar = ttk.Progressbar(frame,
                                                 variable=self.
                                                 load_progress_var,
                                                 maximum=100)

        self.load_progress_bar.grid(row=1, column=0, sticky=&#34;NSEW&#34;)

        self.progress_step = float(100.0/num_patches)

        frame.grid(row=0, column=0, sticky=&#34;NSEW&#34;)
        self.progress_popup.grid_columnconfigure(0, weight=1)

        self.progress_popup.pack_slaves()

        background = self.style.lookup(&#34;TFrame&#34;, &#34;background&#34;)
        self.progress_popup.config(background=background)

    def show_image(self, img, new=False, patch_offset=(0, 0)):
        &#34;&#34;&#34;
        Display the given image on the canvas.

        Args:
            img: The image to display, a numpy array
            new: Whether to reset the canvas for a new image
            patch_offset: The offset of the current patch in the context image
        Returns:
            None

        Postconditions:
            The canvas&#39;s image will be set to the image.
        &#34;&#34;&#34;

        if self._canvas is None:
            self.create_canvas(img)
            return
        elif new:
            self._canvas.new_image(img, patch_offset=patch_offset)

            t = threading.Thread(target=self.update_preview, name=&#34;preview&#34;)
            t.daemon = True
            t.start()

        else:

            self._canvas.set_image(img)

            if self._cur_preview_thread is not None:
                self._cur_preview_thread.cancel()

            self._cur_preview_thread = threading.Timer(1.0,
                                                       self.update_preview)
            self._cur_preview_thread.daemon = True
            self._cur_preview_thread.start()

    def update_preview(self):

        if self._preview_window is not None:
            img = self._controller.get_image_preview()

            self._preview_window.update_image(img)

    def on_canvas_click(self, pos):
        &#34;&#34;&#34;
        Called when the canvas has a click event.

        Args:
            pos: The position of the event.

        Returns:
            None
        &#34;&#34;&#34;
        self._controller.click_event(pos)

    def on_canvas_drag(self, pos, drag_id=None):
        &#34;&#34;&#34;
        Called when the canvas has a drag event.

        Args:
            pos: The position of the drag.
            drag_id: Idenitifier for unique drag events.

        Returns:
            None
        &#34;&#34;&#34;
        self._controller.drag_event(pos, drag_id=drag_id)

    def set_canvas_cursor(self, cursor):
        &#34;&#34;&#34;
        Set the cursor for the canvas.

        Args:
            cursor: The cursor string.

        Returns:
            None

        Postconditions:
            The canvas&#39; cursor will be set.
        &#34;&#34;&#34;
        self._canvas.cursor = cursor

    def set_canvas_brush_size(self, radius):
        &#34;&#34;&#34;
        Set the size of the brush in the canvas.

        Args:
            radius: The radius to draw the brush.

        Returns:
            None

        Postconditions:
            The canvas&#39; brush size is changed.
        &#34;&#34;&#34;
        self._canvas.brush_radius = radius

    def update_canvas_image(self, image):
        &#34;&#34;&#34;
        Set the current image in the canvas.

        Args:
            image: The image, a numpy array

        Returns:
            None

        Postconditions:
            The canvas&#39;s image will be set to the given image data.
        &#34;&#34;&#34;
        if self._canvas is not None:
            self._canvas.img = image

    def update_info_panel(self, tool):
        &#34;&#34;&#34;
        Update the info panel with the activated tool&#39;s widget.

        Args:
            tool: The tool that the info panel should represent.

        Returns:
            None

        Postconditions:
            The info panel will display the widget defined by the tool.
        &#34;&#34;&#34;
        tool.lock_undos()
        if self._old_tool is not None:
            self._old_tool.destroy_info_widget()

        self._info_panel.set_info_widget(tool.
                                         get_info_widget(self._info_panel,
                                                         self.style),
                                         tool.name)

        self._old_tool = tool

    def enable_button(self, id):
        &#34;&#34;&#34;
        Enable the button with the given id.

        Args:
            id: The id of the tool whose button to enable.

        Returns:
            None

        Postconditions:
            The button will be in the enabled state.
        &#34;&#34;&#34;
        self._toolbar_buttons[id].config(state=&#39;normal&#39;)

    def disable_button(self, id):
        &#34;&#34;&#34;
        Disable the button with the given id.

        Args:
            id: The id of the tool whose button to disable.

        Returns:
            None

        Postconditions:
            The button will be in the disabled state.
        &#34;&#34;&#34;
        self._toolbar_buttons[id].config(state=&#39;disabled&#39;)

    def update_image_indicator(self, text):
        &#34;&#34;&#34;
        Update the image indicator in the toolbar with the given text.

        Args:
            text: The text to display in the toolbar.

        Returns:
            None

        Postconditions:
            The text in the toolbar will display the given text.
        &#34;&#34;&#34;
        self._image_indicator.config(text=text)

    def log_mouse_event(self, pos, event, button):
        self._controller.log_mouse_event(pos, event, button)

    def log_drag_event(self, drag_type, start_pos, end_pos):
        self._controller.log_drag_event(drag_type, start_pos, end_pos)

    def log_zoom_event(self, zoom_factor):
        self._controller.log_zoom_event(zoom_factor)

    def set_default_tool(self, id):
        self._update_toolbar_state(id)

    # ==========================================================
    # PRIVATE FUNCTIONS
    # ==========================================================

    def _create_menubar(self):
        &#34;&#34;&#34;
        Create the menu bar.


        Returns:
            None

        Postconditions:
            The menu bar will be created at the top of the screen.
        &#34;&#34;&#34;

        self._menubar = tk.Menu(self.master)

        self._set_menubar_theme()

        self._create_file_menu()

        self._create_view_menu()

        self._create_help_menu()

        self._create_toolbar()

        self._master.config(menu=self._menubar)

    def _create_file_menu(self):
        &#34;&#34;&#34;
        Create the file menu.


        Returns:
            None

        Postconditions:
            The file menu will be populated.
        &#34;&#34;&#34;

        self._filemenu = tk.Menu(self._menubar, tearoff=0)

        self._set_filemenu_theme()

        self._filemenu.add_command(label=&#34;Load Image&#34;,
                                   command=self._on_load_image)

        self._filemenu.add_command(label=&#34;Save Mask&#34;,
                                   command=self._on_save_mask)

        self._filemenu.add_separator()

        self._filemenu.add_command(label=&#34;Load Existing Mask&#34;,
                                   command=self._on_load_mask)

        self._filemenu.add_separator()
        self._filemenu.add_command(label=&#34;Preferences&#34;,
                                   command=self._on_preferences)

        self._menubar.add_cascade(label=&#34;File&#34;, menu=self._filemenu)

    def _create_view_menu(self):
        &#34;&#34;&#34;
        Create the view menu.


        Returns:
            None

        Postconditions:
            The view menu will be populated.
        &#34;&#34;&#34;
        if &#34;preview&#34; not in self._preferences.keys():
            preview_pref = 1
        else:
            preview_pref = self._preferences[&#39;preview&#39;]

        self._viewmenu = tk.Menu(self._menubar, tearoff=0)

        self._preview_setting = tk.IntVar()
        self._preview_setting.set(preview_pref)

        submenu = tk.Menu(self._menubar)
        submenu.add_radiobutton(label=&#34;Docked&#34;, value=1,
                                variable=self._preview_setting,
                                command=self._on_preview_setting)

        submenu.add_radiobutton(label=&#34;Floating&#34;, value=2,
                                variable=self._preview_setting,
                                command=self._on_preview_setting)

        submenu.add_radiobutton(label=&#34;Hidden&#34;, value=3,
                                variable=self._preview_setting,
                                command=self._on_preview_setting)

        self._previewmenu = submenu

        self._set_viewmenu_theme()

        self._menubar.add_cascade(label=&#34;View&#34;, menu=self._viewmenu)
        self._viewmenu.add_cascade(label=&#34;Preview&#34;, menu=submenu)

    def _on_preview_setting(self):
        &#34;&#34;&#34;
        Called when the user changes the preview window settings.


        Returns:
            None
        &#34;&#34;&#34;

        # Set to docked
        if self._preview_setting.get() == 1:
            self._dock_preview()
        # Set to floating
        elif self._preview_setting.get() == 2:
            self._float_preview()
        # Set to hidden
        else:
            self._hide_preview()

        self._preferences[&#39;preview&#39;] = self._preview_setting.get()

        self._controller.save_preferences(self._preferences)

    def _dock_preview(self):

        if self._preview_window is not None:
            self._preview_window.destroy()

        self._preview_window = PreviewFrame(self.master,
                                            self._controller
                                            .get_image_preview(),
                                            self._controller, self.style)

        self._preview_window.grid(row=1, column=1, sticky=&#34;NSEW&#34;)

        self._master.grid_rowconfigure(0, weight=0)
        self._master.grid_rowconfigure(1, weight=1)

        self._master.grid_columnconfigure(0, weight=3)
        self._master.grid_columnconfigure(1, weight=1)

    def _float_preview(self):

        if self._preview_window is not None:
            self._preview_window.destroy()

        self._preview_window = PreviewWindow(self._controller
                                             .get_image_preview(),
                                             self._controller, self.style)

        self._master.grid_columnconfigure(0, weight=1)
        self._master.grid_columnconfigure(1, weight=0)

    def _hide_preview(self):

        if self._preview_window is not None:
            self._preview_window.destroy()

        self._master.grid_columnconfigure(0, weight=1)
        self._master.grid_columnconfigure(1, weight=0)

        self._preview_window = None

    def _create_help_menu(self):
        &#34;&#34;&#34;
        Create the help menu.


        Returns:
            None

        Postconditions:
            The help menu will be populated.
        &#34;&#34;&#34;

        self._helpmenu = tk.Menu(self._menubar, tearoff=0)

        self._set_helpmenu_theme()

        self._helpmenu.add_command(label=&#34;About&#34;,
                                   command=self._on_about)

        self._helpmenu.add_command(label=&#34;Keyboard Shortcuts&#34;,
                                   command=self._on_keyboard_shortcuts)

        self._menubar.add_cascade(label=&#34;Help&#34;, menu=self._helpmenu)

    def _create_tool_tip(self, button, id, name):
        &#34;&#34;&#34;
        Create a tool tip for the given button.

        Args:
            button: The button to create the tooltip for.
            id: The id of the tool.
            name: The name of the tool
        Returns:
            None

        Postcondition:
            The tooltip is attached to the button.
        &#34;&#34;&#34;
        key = self._key_mappings[id]

        tip = name + &#34;(&#34; + key + &#34;)&#34;

        CreateToolTip(button, tip)

    def _create_toolbar(self):
        &#34;&#34;&#34;
        Create the toolbar.


        Returns:
            None

        Postconditions:
            The toolbar is created.
        &#34;&#34;&#34;

        self._toolbar = ttk.Frame(self._master, style=&#34;Toolbar.TFrame&#34;)

        # Create image interaction tools
        image_tools = self._controller.image_tools

        group_priorities = [(0, &#34;Markups&#34;), (1, &#34;Navigation&#34;), (2, &#34;Undo&#34;)]

        groups = [[] for _ in group_priorities]
        groups.append([])

        for tool_id in image_tools.keys():
            tool = image_tools[tool_id]

            tool_group = tool.group

            in_priors = False

            for p in group_priorities:
                if tool_group == p[1]:
                    groups[p[0]].append(tool)
                    in_priors = True
                    continue

            if not in_priors:
                groups[-1].append(tool)

        if len(groups[-1]) == 0:
            groups.pop()

        column = 0
        for group in groups:
            for tool in group:
                icon = self._load_icon_from_string(tool.icon_string)
                command = partial(self._on_tool_selected, tool.id)

                if tool.persistant:
                    button_style = &#34;PersistantToolbar.TButton&#34;
                else:
                    button_style = &#34;Toolbar.TButton&#34;

                button = ttk.Button(self._toolbar, image=icon,
                                    style=button_style,
                                    command=command)

                button.image = icon
                button.pack(side=&#34;left&#34;, padx=2, pady=2)
                # button.grid(column=column, row=0, sticky=&#39;EW&#39;)
                column += 1

                self._create_tool_tip(button, tool.id, tool.name)
                self._toolbar_buttons[tool.id] = button

            sep = tk.ttk.Separator(self._toolbar, orient=&#34;vertical&#34;,
                                   style=&#34;TSeparator&#34;)
            sep.pack(side=&#39;left&#39;, padx=5, fill=&#39;both&#39;)

        self._image_indicator = ttk.Label(self._toolbar,
                                          text=&#34;No Image Loaded&#34;,
                                          style=&#34;Toolbar.TLabel&#34;)

        self._image_indicator.pack(side=&#39;right&#39;, padx=2, pady=2)
        self._toolbar.grid(column=0, row=0, sticky=&#39;NEW&#39;, columnspan=2)

    def _enable_darkmode_buttons(self):
        &#34;&#34;&#34;
        Switch the icons for the buttons to dark mode.


        Returns:
            None
        &#34;&#34;&#34;
        for key in self._toolbar_buttons:
            tool = self._controller.image_tools[key]
            button = self._toolbar_buttons[key]

            icon = self._load_icon_from_string(tool.darkmode_icon_string)

            button.config(image=icon)
            button.image = icon

    def _keystroke(self, event):
        &#34;&#34;&#34;
        Called when the keybord is used.

        Args:
            event: The keyboard event.

        Returns:
            None

        Postconditions:
            The canvas is modified according to the key pressed.
        &#34;&#34;&#34;
        key = &#39;&#39;

        # means that the Control key is pressed
        if event.state - self._previous_state == 4:
            key = &#34;CTRL+&#34;
        else:
            # remember the last keystroke state
            self._previous_state = event.state

        key += event.keysym.lower()

        self._logger.debug(&#34;KEY: &#34; + key)

        if key == &#34;CTRL+equal&#34; or key == &#34;CTRL+=&#34;:
            self._controller.adjust_tool(1)
        elif key == &#34;CTRL+minus&#34; or key == &#34;CTRL+-&#34;:
            self._controller.adjust_tool(-1)
        elif key == &#34;f11&#34;:
            self._master.attributes(&#39;-fullscreen&#39;, True)
        elif key == &#34;escape&#34;:
            self._master.attributes(&#39;-fullscreen&#39;, False)
        else:
            try:
                tool_id = self._reverse_key_mappings[key]
                self._on_tool_selected(tool_id)
            except KeyError:
                self._logger.debug(&#34;{} is not a valid key code&#34;.format(key))

    def _load_icon_from_string(self, icon_string):
        &#34;&#34;&#34;
        Load a tkinter compatible image from an icon bytestring.

        Args:
            icon_string: The 64 bit encoded icon string

        Returns:
            A ImageTK PhotoImage
        &#34;&#34;&#34;
        data = Image.open(BytesIO(base64.b64decode(icon_string)))
        img = itk.PhotoImage(data)

        return img

    def _on_load_image(self):
        &#34;&#34;&#34;
        Called when the load image button is chosen


        Returns:
            None

        Postconditions:
            The controllers Image property is set
        &#34;&#34;&#34;
        self._controller.load_new_image()
        self._old_img = None

    def _on_load_mask(self):
        &#34;&#34;&#34;
        Called when the load existing mask button is chosen.


        Returns:
            None
        &#34;&#34;&#34;

        self._controller.load_existing_mask()

    def _on_save_mask(self):
        &#34;&#34;&#34;
        Called when the save mask button is chosen

        Returns:
            None

        Postcondition:
            The controller will be called to save the mask.

        Returns:
            None
        &#34;&#34;&#34;
        self._controller.save_mask()

    def _on_preferences(self):
        &#34;&#34;&#34;
        Called when the preferences menu option is chosen.


        Returns:
            None
        &#34;&#34;&#34;
        PreferencesWindow(self._controller, self.style)

    def _on_about(self):
        &#34;&#34;&#34;
        Called when the about button is chosen.


        Returns:
            None
        &#34;&#34;&#34;
        AboutDialog()

    def _on_keyboard_shortcuts(self):
        &#34;&#34;&#34;
        Called when the keyboard shortcuts button is chosen/


        Returns:
            None
        &#34;&#34;&#34;
        KeyboardShortcutDialog(self._controller.image_tools, self._darkmode)

    def _on_tool_selected(self, id):
        &#34;&#34;&#34;
        Called when a tool is selected in the menubar

        Args:
            id: The id of the tool.

        Returns:
            None

        Postconditions:
            The controller is updated to reflect the current chosen tool.
        &#34;&#34;&#34;
        self._controller.activate_tool(id)
        self._update_toolbar_state(id)

    def _register_key_mappings(self):
        &#34;&#34;&#34;
        Register a mapping of tool ids to keys.


        Returns:
            None

        Postconditions:
            self._key_mappings will contain a dictionary of id -&gt; key mappings
        &#34;&#34;&#34;
        for tool_id in self._controller.image_tools.keys():
            tool = self._controller.image_tools[tool_id]
            self._key_mappings[tool_id] = tool.key_mapping

        for tool_id in self._key_mappings.keys():
            key = self._key_mappings[tool_id]

            self._reverse_key_mappings[key] = tool_id

    def _update_toolbar_state(self, tool_id):
        &#34;&#34;&#34;
        Change the state of the buttons in the toolbar based on the button that
        has been chosen.

        Args:
            tool_id: The id of the tool that was chosen

        Returns:
            None

        Postconditions:
            The toolbar button matching the given id will be activated.
        &#34;&#34;&#34;

        if not self._controller.image_tools[tool_id].persistant:
            return

        for id, button in self._toolbar_buttons.items():
            if id == tool_id and self._controller.image_tools[id].persistant:
                button.state([&#39;disabled&#39;])
            else:
                button.state([&#39;!disabled&#39;])

    def _on_mousewheel(self, event):
        &#34;&#34;&#34;
        Called when the mousewheel is scrolled.

        Args:
            event: The mouse event

        Returns:
            None
        &#34;&#34;&#34;

        # On Linux, the events are different
        if event.num == 4:
            rotation = 120
        elif event.num == 5:
            rotation = -120

        # For Windows and Mac
        if event.delta != 0:
            rotation = event.delta

        # If control is down)
        if event.state - self._previous_state == 4:
            self._controller.adjust_tool(rotation)

    def _set_menubar_theme(self):
        &#34;&#34;&#34;
        Set the theme for the menubar.


        Returns:
            None
        &#34;&#34;&#34;

        background = self.style.lookup(&#39;MenuBar.TMenubutton&#39;, &#39;background&#39;)
        foreground = self.style.lookup(&#39;MenuBar.TMenubutton&#39;, &#39;foreground&#39;)

        activebackground = self.style.lookup(&#39;MenuBar.TMenubutton&#39;,
                                             &#39;activebackground&#39;)
        activeforeground = self.style.lookup(&#39;MenuBar.TMenubutton&#39;,
                                             &#39;activeforeground&#39;)

        self._menubar.config(background=background, foreground=foreground,
                             activebackground=activebackground,
                             activeforeground=activeforeground)

    def _set_filemenu_theme(self):

        background = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;background&#39;)
        foreground = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;foreground&#39;)

        activebackground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activebackground&#39;)
        activeforeground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activeforeground&#39;)

        self._filemenu.config(background=background, foreground=foreground,
                              activebackground=activebackground,
                              activeforeground=activeforeground)

    def _set_viewmenu_theme(self):

        background = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;background&#39;)
        foreground = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;foreground&#39;)

        activebackground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activebackground&#39;)
        activeforeground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activeforeground&#39;)

        self._viewmenu.config(background=background, foreground=foreground,
                              activebackground=activebackground,
                              activeforeground=activeforeground)

        self._previewmenu.config(background=background, foreground=foreground,
                                 activebackground=activebackground,
                                 activeforeground=activeforeground)

    def _set_helpmenu_theme(self):

        background = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;background&#39;)
        foreground = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;foreground&#39;)

        activebackground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activebackground&#39;)
        activeforeground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activeforeground&#39;)

        self._helpmenu.config(background=background, foreground=foreground,
                              activebackground=activebackground,
                              activeforeground=activeforeground)

    def _set_master_theme(self):
        background = self.style.lookup(&#39;Main.TFrame&#39;, &#39;background&#39;)
        self._master.config(background=background)


class CreateToolTip(object):
    &#34;&#34;&#34;
    create a tooltip for a given widget
    &#34;&#34;&#34;
    def __init__(self, widget, text=&#39;widget info&#39;):
        self.waittime = 500     # miliseconds
        self.wraplength = 180   # pixels
        self.widget = widget
        self.text = text
        self.widget.bind(&#34;&lt;Enter&gt;&#34;, self.enter)
        self.widget.bind(&#34;&lt;Leave&gt;&#34;, self.leave)
        self.widget.bind(&#34;&lt;ButtonPress&gt;&#34;, self.leave)
        self.id = None
        self.tw = None

    def enter(self, event=None):
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(self.waittime, self.showtip)

    def unschedule(self):
        id = self.id
        self.id = None
        if id:
            self.widget.after_cancel(id)

    def showtip(self, event=None):
        x = y = 0
        x, y, cx, cy = self.widget.bbox(&#34;insert&#34;)
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        # creates a toplevel window
        self.tw = tk.Toplevel(self.widget)
        # Leaves only the label and removes the app window
        self.tw.wm_overrideredirect(True)
        self.tw.wm_geometry(&#34;+%d+%d&#34; % (x, y))
        label = tk.Label(self.tw, text=self.text, justify=&#39;left&#39;,
                         background=&#34;#ffffff&#34;, relief=&#39;solid&#39;, borderwidth=1,
                         wraplength=self.wraplength)
        label.pack(ipadx=1)

    def hidetip(self):
        tw = self.tw
        self.tw = None
        if tw:
            tw.destroy()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="friendly_ground_truth.view.main_window.CreateToolTip"><code class="flex name class">
<span>class <span class="ident">CreateToolTip</span></span>
<span>(</span><span>widget, text='widget info')</span>
</code></dt>
<dd>
<div class="desc"><p>create a tooltip for a given widget</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CreateToolTip(object):
    &#34;&#34;&#34;
    create a tooltip for a given widget
    &#34;&#34;&#34;
    def __init__(self, widget, text=&#39;widget info&#39;):
        self.waittime = 500     # miliseconds
        self.wraplength = 180   # pixels
        self.widget = widget
        self.text = text
        self.widget.bind(&#34;&lt;Enter&gt;&#34;, self.enter)
        self.widget.bind(&#34;&lt;Leave&gt;&#34;, self.leave)
        self.widget.bind(&#34;&lt;ButtonPress&gt;&#34;, self.leave)
        self.id = None
        self.tw = None

    def enter(self, event=None):
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(self.waittime, self.showtip)

    def unschedule(self):
        id = self.id
        self.id = None
        if id:
            self.widget.after_cancel(id)

    def showtip(self, event=None):
        x = y = 0
        x, y, cx, cy = self.widget.bbox(&#34;insert&#34;)
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        # creates a toplevel window
        self.tw = tk.Toplevel(self.widget)
        # Leaves only the label and removes the app window
        self.tw.wm_overrideredirect(True)
        self.tw.wm_geometry(&#34;+%d+%d&#34; % (x, y))
        label = tk.Label(self.tw, text=self.text, justify=&#39;left&#39;,
                         background=&#34;#ffffff&#34;, relief=&#39;solid&#39;, borderwidth=1,
                         wraplength=self.wraplength)
        label.pack(ipadx=1)

    def hidetip(self):
        tw = self.tw
        self.tw = None
        if tw:
            tw.destroy()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.view.main_window.CreateToolTip.enter"><code class="name flex">
<span>def <span class="ident">enter</span></span>(<span>self, event=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enter(self, event=None):
    self.schedule()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.CreateToolTip.hidetip"><code class="name flex">
<span>def <span class="ident">hidetip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hidetip(self):
    tw = self.tw
    self.tw = None
    if tw:
        tw.destroy()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.CreateToolTip.leave"><code class="name flex">
<span>def <span class="ident">leave</span></span>(<span>self, event=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def leave(self, event=None):
    self.unschedule()
    self.hidetip()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.CreateToolTip.schedule"><code class="name flex">
<span>def <span class="ident">schedule</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def schedule(self):
    self.unschedule()
    self.id = self.widget.after(self.waittime, self.showtip)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.CreateToolTip.showtip"><code class="name flex">
<span>def <span class="ident">showtip</span></span>(<span>self, event=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showtip(self, event=None):
    x = y = 0
    x, y, cx, cy = self.widget.bbox(&#34;insert&#34;)
    x += self.widget.winfo_rootx() + 25
    y += self.widget.winfo_rooty() + 20
    # creates a toplevel window
    self.tw = tk.Toplevel(self.widget)
    # Leaves only the label and removes the app window
    self.tw.wm_overrideredirect(True)
    self.tw.wm_geometry(&#34;+%d+%d&#34; % (x, y))
    label = tk.Label(self.tw, text=self.text, justify=&#39;left&#39;,
                     background=&#34;#ffffff&#34;, relief=&#39;solid&#39;, borderwidth=1,
                     wraplength=self.wraplength)
    label.pack(ipadx=1)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.CreateToolTip.unschedule"><code class="name flex">
<span>def <span class="ident">unschedule</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unschedule(self):
    id = self.id
    self.id = None
    if id:
        self.widget.after_cancel(id)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow"><code class="flex name class">
<span>class <span class="ident">MainWindow</span></span>
<span>(</span><span>master, controller)</span>
</code></dt>
<dd>
<div class="desc"><p>The main window for the application.</p>
<h2 id="attributes">Attributes</h2>
<p>{% An Attribute %}: {% Description %}
Initialize the main window.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>master</code></strong></dt>
<dd>The root tkinter process.</dd>
<dt><strong><code>controller</code></strong></dt>
<dd>The controller logic</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A main window object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainWindow(ttk.Frame):
    &#34;&#34;&#34;
    The main window for the application.

    Attributes:
        {% An Attribute %}: {% Description %}
    &#34;&#34;&#34;

    def __init__(self, master, controller):
        &#34;&#34;&#34;
        Initialize the main window.

        Args:
            master: The root tkinter process.
            controller: The controller logic

        Returns:
            A main window object.
        &#34;&#34;&#34;

        self._preview_window = None
        self._cur_preview_thread = None

        preferences = controller.load_preferences()

        self._preferences = preferences

        theme = preferences[&#39;theme&#39;]

        if theme == &#39;Light&#39;:
            self._darkmode = False
        elif theme == &#39;Dark&#39;:
            self._darkmode = True

        if self._darkmode:
            from friendly_ground_truth.view import dark_theme

            dark_theme.style.theme_use(&#34;dark_theme&#34;)
            self.style = dark_theme.style

        else:
            from friendly_ground_truth.view import light_theme
            light_theme.style.theme_use(&#34;light_theme&#34;)
            self.style = light_theme.style

        ttk.Frame.__init__(self, master=master, style=&#34;Main.TFrame&#34;)

        # --------------------------------------
        # Private Attributes
        # --------------------------------------

        # The parent tkinter object
        self._master = master
        # The controller for this window
        self._controller = controller

        # For logging
        self._logger = logging.getLogger(&#39;friendly_gt.view.MainWindow&#39;)

        # The canvas used to display and interact with images
        self._canvas = None

        # The previous state of the keyboard
        self._previous_state = 0

        # Mappings from tool id to keyboard shortcut
        self._key_mappings = {}
        # Mappings from keyboard shortcut to tool id
        self._reverse_key_mappings = {}

        # Tkinter menu objects
        self._menubar = None
        self._filemenu = None
        self._helpmenu = None

        # Toolbar
        self._toolbar = None
        # id -&gt; button mapping
        self._toolbar_buttons = {}
        # The colour of a default button
        self._orig_button_colour = None
        # The label displaying the path to the current image
        self._image_indicator = None

        self._old_tool_id = None
        # The previous image
        self._old_img = None

        self._old_tool = None
        # --------------------------------------

        self._master.title(&#34;Friendly Ground Truth&#34;)
        self._master.columnconfigure(0, weight=1)

        self._master.grid_rowconfigure(0, weight=0)
        self._master.grid_rowconfigure(1, weight=1)

        self._set_master_theme()

        self._register_key_mappings()

        self._create_menubar()

        # Interactions
        self.bind_all(&#39;&lt;Key&gt;&#39;, self._keystroke)
        # Mousewheel for Windows and Mac
        self.bind_all(&#34;&lt;MouseWheel&gt;&#34;, self._on_mousewheel)

        # Mousewheel for Linux
        self.bind_all(&#34;&lt;Button-5&gt;&#34;, self._on_mousewheel)
        self.bind_all(&#34;&lt;Button-4&gt;&#34;, self._on_mousewheel)

        self._info_panel = InfoPanel(self.master)
        self._info_panel.config(style=&#34;InfoPanel.TFrame&#34;)

        self._info_panel.grid(row=2, column=0, sticky=&#39;ew&#39;, columnspan=2)

        if self._darkmode:
            self._enable_darkmode_buttons()
    # ==========================================================
    # PUBLIC FUNCTIONS
    # ==========================================================

    def create_canvas(self, image):
        &#34;&#34;&#34;
        Create the image canvas.

        Args:
            image: The image, a numpy array.

        Returns:
            None

        Postconditions:
            self._canvas is set
        &#34;&#34;&#34;
        if self._canvas is not None:
            self._canvas.destroy()

        self._canvas = FGTCanvas(self.master, image, self, self.style)
        self._canvas.grid(row=1, column=0, sticky=&#34;NSEW&#34;)

        self._on_preview_setting()

    def set_theme(self, theme):
        &#34;&#34;&#34;
        Set the current theme for the application.

        Args:
            theme: A string.

        Returns:
            None
        &#34;&#34;&#34;

        if theme.lower() == &#39;dark&#39;:
            self._darkmode = True

            from friendly_ground_truth.view import dark_theme

            dark_theme.style.theme_use(&#34;dark_theme&#34;)
            self.style = dark_theme.style

            self._enable_darkmode_buttons()

        elif theme.lower() == &#39;light&#39;:
            self._darkmode = False
            from friendly_ground_truth.view import light_theme

            light_theme.style.theme_use(&#34;light_theme&#34;)
            self.style = light_theme.style

            self._toolbar.destroy()
            self._create_toolbar()

        self._set_menubar_theme()
        self._set_helpmenu_theme()
        self._set_viewmenu_theme()
        self._set_master_theme()
        self._set_filemenu_theme()

        self._canvas.set_theme(self.style)

        if self._preview_window is not None:
            self._preview_window.set_theme(self.style)

    def start_progressbar(self, num_patches):
        &#34;&#34;&#34;
        Start displaying a progressbar.

        Args:
            num_patches: The number of patches that are being loaded.

        Returns:
            None

        Postconditions:
            A progressbar window is opened and initialized
        &#34;&#34;&#34;
        self.progress_popup = tk.Toplevel()
        self.progress_popup.geometry(&#34;100x50+500+400&#34;)

        frame = ttk.Frame(self.progress_popup)

        ttk.Label(frame, text=&#34;Image Loading.&#34;)\
            .grid(row=0, column=0)

        self.load_progress = 0
        self.load_progress_var = tk.DoubleVar()
        self.load_progress_bar = ttk.Progressbar(frame,
                                                 variable=self.
                                                 load_progress_var,
                                                 maximum=100)

        self.load_progress_bar.grid(row=1, column=0, sticky=&#34;NSEW&#34;)

        self.progress_step = float(100.0/num_patches)

        frame.grid(row=0, column=0, sticky=&#34;NSEW&#34;)
        self.progress_popup.grid_columnconfigure(0, weight=1)

        self.progress_popup.pack_slaves()

        background = self.style.lookup(&#34;TFrame&#34;, &#34;background&#34;)
        self.progress_popup.config(background=background)

    def show_image(self, img, new=False, patch_offset=(0, 0)):
        &#34;&#34;&#34;
        Display the given image on the canvas.

        Args:
            img: The image to display, a numpy array
            new: Whether to reset the canvas for a new image
            patch_offset: The offset of the current patch in the context image
        Returns:
            None

        Postconditions:
            The canvas&#39;s image will be set to the image.
        &#34;&#34;&#34;

        if self._canvas is None:
            self.create_canvas(img)
            return
        elif new:
            self._canvas.new_image(img, patch_offset=patch_offset)

            t = threading.Thread(target=self.update_preview, name=&#34;preview&#34;)
            t.daemon = True
            t.start()

        else:

            self._canvas.set_image(img)

            if self._cur_preview_thread is not None:
                self._cur_preview_thread.cancel()

            self._cur_preview_thread = threading.Timer(1.0,
                                                       self.update_preview)
            self._cur_preview_thread.daemon = True
            self._cur_preview_thread.start()

    def update_preview(self):

        if self._preview_window is not None:
            img = self._controller.get_image_preview()

            self._preview_window.update_image(img)

    def on_canvas_click(self, pos):
        &#34;&#34;&#34;
        Called when the canvas has a click event.

        Args:
            pos: The position of the event.

        Returns:
            None
        &#34;&#34;&#34;
        self._controller.click_event(pos)

    def on_canvas_drag(self, pos, drag_id=None):
        &#34;&#34;&#34;
        Called when the canvas has a drag event.

        Args:
            pos: The position of the drag.
            drag_id: Idenitifier for unique drag events.

        Returns:
            None
        &#34;&#34;&#34;
        self._controller.drag_event(pos, drag_id=drag_id)

    def set_canvas_cursor(self, cursor):
        &#34;&#34;&#34;
        Set the cursor for the canvas.

        Args:
            cursor: The cursor string.

        Returns:
            None

        Postconditions:
            The canvas&#39; cursor will be set.
        &#34;&#34;&#34;
        self._canvas.cursor = cursor

    def set_canvas_brush_size(self, radius):
        &#34;&#34;&#34;
        Set the size of the brush in the canvas.

        Args:
            radius: The radius to draw the brush.

        Returns:
            None

        Postconditions:
            The canvas&#39; brush size is changed.
        &#34;&#34;&#34;
        self._canvas.brush_radius = radius

    def update_canvas_image(self, image):
        &#34;&#34;&#34;
        Set the current image in the canvas.

        Args:
            image: The image, a numpy array

        Returns:
            None

        Postconditions:
            The canvas&#39;s image will be set to the given image data.
        &#34;&#34;&#34;
        if self._canvas is not None:
            self._canvas.img = image

    def update_info_panel(self, tool):
        &#34;&#34;&#34;
        Update the info panel with the activated tool&#39;s widget.

        Args:
            tool: The tool that the info panel should represent.

        Returns:
            None

        Postconditions:
            The info panel will display the widget defined by the tool.
        &#34;&#34;&#34;
        tool.lock_undos()
        if self._old_tool is not None:
            self._old_tool.destroy_info_widget()

        self._info_panel.set_info_widget(tool.
                                         get_info_widget(self._info_panel,
                                                         self.style),
                                         tool.name)

        self._old_tool = tool

    def enable_button(self, id):
        &#34;&#34;&#34;
        Enable the button with the given id.

        Args:
            id: The id of the tool whose button to enable.

        Returns:
            None

        Postconditions:
            The button will be in the enabled state.
        &#34;&#34;&#34;
        self._toolbar_buttons[id].config(state=&#39;normal&#39;)

    def disable_button(self, id):
        &#34;&#34;&#34;
        Disable the button with the given id.

        Args:
            id: The id of the tool whose button to disable.

        Returns:
            None

        Postconditions:
            The button will be in the disabled state.
        &#34;&#34;&#34;
        self._toolbar_buttons[id].config(state=&#39;disabled&#39;)

    def update_image_indicator(self, text):
        &#34;&#34;&#34;
        Update the image indicator in the toolbar with the given text.

        Args:
            text: The text to display in the toolbar.

        Returns:
            None

        Postconditions:
            The text in the toolbar will display the given text.
        &#34;&#34;&#34;
        self._image_indicator.config(text=text)

    def log_mouse_event(self, pos, event, button):
        self._controller.log_mouse_event(pos, event, button)

    def log_drag_event(self, drag_type, start_pos, end_pos):
        self._controller.log_drag_event(drag_type, start_pos, end_pos)

    def log_zoom_event(self, zoom_factor):
        self._controller.log_zoom_event(zoom_factor)

    def set_default_tool(self, id):
        self._update_toolbar_state(id)

    # ==========================================================
    # PRIVATE FUNCTIONS
    # ==========================================================

    def _create_menubar(self):
        &#34;&#34;&#34;
        Create the menu bar.


        Returns:
            None

        Postconditions:
            The menu bar will be created at the top of the screen.
        &#34;&#34;&#34;

        self._menubar = tk.Menu(self.master)

        self._set_menubar_theme()

        self._create_file_menu()

        self._create_view_menu()

        self._create_help_menu()

        self._create_toolbar()

        self._master.config(menu=self._menubar)

    def _create_file_menu(self):
        &#34;&#34;&#34;
        Create the file menu.


        Returns:
            None

        Postconditions:
            The file menu will be populated.
        &#34;&#34;&#34;

        self._filemenu = tk.Menu(self._menubar, tearoff=0)

        self._set_filemenu_theme()

        self._filemenu.add_command(label=&#34;Load Image&#34;,
                                   command=self._on_load_image)

        self._filemenu.add_command(label=&#34;Save Mask&#34;,
                                   command=self._on_save_mask)

        self._filemenu.add_separator()

        self._filemenu.add_command(label=&#34;Load Existing Mask&#34;,
                                   command=self._on_load_mask)

        self._filemenu.add_separator()
        self._filemenu.add_command(label=&#34;Preferences&#34;,
                                   command=self._on_preferences)

        self._menubar.add_cascade(label=&#34;File&#34;, menu=self._filemenu)

    def _create_view_menu(self):
        &#34;&#34;&#34;
        Create the view menu.


        Returns:
            None

        Postconditions:
            The view menu will be populated.
        &#34;&#34;&#34;
        if &#34;preview&#34; not in self._preferences.keys():
            preview_pref = 1
        else:
            preview_pref = self._preferences[&#39;preview&#39;]

        self._viewmenu = tk.Menu(self._menubar, tearoff=0)

        self._preview_setting = tk.IntVar()
        self._preview_setting.set(preview_pref)

        submenu = tk.Menu(self._menubar)
        submenu.add_radiobutton(label=&#34;Docked&#34;, value=1,
                                variable=self._preview_setting,
                                command=self._on_preview_setting)

        submenu.add_radiobutton(label=&#34;Floating&#34;, value=2,
                                variable=self._preview_setting,
                                command=self._on_preview_setting)

        submenu.add_radiobutton(label=&#34;Hidden&#34;, value=3,
                                variable=self._preview_setting,
                                command=self._on_preview_setting)

        self._previewmenu = submenu

        self._set_viewmenu_theme()

        self._menubar.add_cascade(label=&#34;View&#34;, menu=self._viewmenu)
        self._viewmenu.add_cascade(label=&#34;Preview&#34;, menu=submenu)

    def _on_preview_setting(self):
        &#34;&#34;&#34;
        Called when the user changes the preview window settings.


        Returns:
            None
        &#34;&#34;&#34;

        # Set to docked
        if self._preview_setting.get() == 1:
            self._dock_preview()
        # Set to floating
        elif self._preview_setting.get() == 2:
            self._float_preview()
        # Set to hidden
        else:
            self._hide_preview()

        self._preferences[&#39;preview&#39;] = self._preview_setting.get()

        self._controller.save_preferences(self._preferences)

    def _dock_preview(self):

        if self._preview_window is not None:
            self._preview_window.destroy()

        self._preview_window = PreviewFrame(self.master,
                                            self._controller
                                            .get_image_preview(),
                                            self._controller, self.style)

        self._preview_window.grid(row=1, column=1, sticky=&#34;NSEW&#34;)

        self._master.grid_rowconfigure(0, weight=0)
        self._master.grid_rowconfigure(1, weight=1)

        self._master.grid_columnconfigure(0, weight=3)
        self._master.grid_columnconfigure(1, weight=1)

    def _float_preview(self):

        if self._preview_window is not None:
            self._preview_window.destroy()

        self._preview_window = PreviewWindow(self._controller
                                             .get_image_preview(),
                                             self._controller, self.style)

        self._master.grid_columnconfigure(0, weight=1)
        self._master.grid_columnconfigure(1, weight=0)

    def _hide_preview(self):

        if self._preview_window is not None:
            self._preview_window.destroy()

        self._master.grid_columnconfigure(0, weight=1)
        self._master.grid_columnconfigure(1, weight=0)

        self._preview_window = None

    def _create_help_menu(self):
        &#34;&#34;&#34;
        Create the help menu.


        Returns:
            None

        Postconditions:
            The help menu will be populated.
        &#34;&#34;&#34;

        self._helpmenu = tk.Menu(self._menubar, tearoff=0)

        self._set_helpmenu_theme()

        self._helpmenu.add_command(label=&#34;About&#34;,
                                   command=self._on_about)

        self._helpmenu.add_command(label=&#34;Keyboard Shortcuts&#34;,
                                   command=self._on_keyboard_shortcuts)

        self._menubar.add_cascade(label=&#34;Help&#34;, menu=self._helpmenu)

    def _create_tool_tip(self, button, id, name):
        &#34;&#34;&#34;
        Create a tool tip for the given button.

        Args:
            button: The button to create the tooltip for.
            id: The id of the tool.
            name: The name of the tool
        Returns:
            None

        Postcondition:
            The tooltip is attached to the button.
        &#34;&#34;&#34;
        key = self._key_mappings[id]

        tip = name + &#34;(&#34; + key + &#34;)&#34;

        CreateToolTip(button, tip)

    def _create_toolbar(self):
        &#34;&#34;&#34;
        Create the toolbar.


        Returns:
            None

        Postconditions:
            The toolbar is created.
        &#34;&#34;&#34;

        self._toolbar = ttk.Frame(self._master, style=&#34;Toolbar.TFrame&#34;)

        # Create image interaction tools
        image_tools = self._controller.image_tools

        group_priorities = [(0, &#34;Markups&#34;), (1, &#34;Navigation&#34;), (2, &#34;Undo&#34;)]

        groups = [[] for _ in group_priorities]
        groups.append([])

        for tool_id in image_tools.keys():
            tool = image_tools[tool_id]

            tool_group = tool.group

            in_priors = False

            for p in group_priorities:
                if tool_group == p[1]:
                    groups[p[0]].append(tool)
                    in_priors = True
                    continue

            if not in_priors:
                groups[-1].append(tool)

        if len(groups[-1]) == 0:
            groups.pop()

        column = 0
        for group in groups:
            for tool in group:
                icon = self._load_icon_from_string(tool.icon_string)
                command = partial(self._on_tool_selected, tool.id)

                if tool.persistant:
                    button_style = &#34;PersistantToolbar.TButton&#34;
                else:
                    button_style = &#34;Toolbar.TButton&#34;

                button = ttk.Button(self._toolbar, image=icon,
                                    style=button_style,
                                    command=command)

                button.image = icon
                button.pack(side=&#34;left&#34;, padx=2, pady=2)
                # button.grid(column=column, row=0, sticky=&#39;EW&#39;)
                column += 1

                self._create_tool_tip(button, tool.id, tool.name)
                self._toolbar_buttons[tool.id] = button

            sep = tk.ttk.Separator(self._toolbar, orient=&#34;vertical&#34;,
                                   style=&#34;TSeparator&#34;)
            sep.pack(side=&#39;left&#39;, padx=5, fill=&#39;both&#39;)

        self._image_indicator = ttk.Label(self._toolbar,
                                          text=&#34;No Image Loaded&#34;,
                                          style=&#34;Toolbar.TLabel&#34;)

        self._image_indicator.pack(side=&#39;right&#39;, padx=2, pady=2)
        self._toolbar.grid(column=0, row=0, sticky=&#39;NEW&#39;, columnspan=2)

    def _enable_darkmode_buttons(self):
        &#34;&#34;&#34;
        Switch the icons for the buttons to dark mode.


        Returns:
            None
        &#34;&#34;&#34;
        for key in self._toolbar_buttons:
            tool = self._controller.image_tools[key]
            button = self._toolbar_buttons[key]

            icon = self._load_icon_from_string(tool.darkmode_icon_string)

            button.config(image=icon)
            button.image = icon

    def _keystroke(self, event):
        &#34;&#34;&#34;
        Called when the keybord is used.

        Args:
            event: The keyboard event.

        Returns:
            None

        Postconditions:
            The canvas is modified according to the key pressed.
        &#34;&#34;&#34;
        key = &#39;&#39;

        # means that the Control key is pressed
        if event.state - self._previous_state == 4:
            key = &#34;CTRL+&#34;
        else:
            # remember the last keystroke state
            self._previous_state = event.state

        key += event.keysym.lower()

        self._logger.debug(&#34;KEY: &#34; + key)

        if key == &#34;CTRL+equal&#34; or key == &#34;CTRL+=&#34;:
            self._controller.adjust_tool(1)
        elif key == &#34;CTRL+minus&#34; or key == &#34;CTRL+-&#34;:
            self._controller.adjust_tool(-1)
        elif key == &#34;f11&#34;:
            self._master.attributes(&#39;-fullscreen&#39;, True)
        elif key == &#34;escape&#34;:
            self._master.attributes(&#39;-fullscreen&#39;, False)
        else:
            try:
                tool_id = self._reverse_key_mappings[key]
                self._on_tool_selected(tool_id)
            except KeyError:
                self._logger.debug(&#34;{} is not a valid key code&#34;.format(key))

    def _load_icon_from_string(self, icon_string):
        &#34;&#34;&#34;
        Load a tkinter compatible image from an icon bytestring.

        Args:
            icon_string: The 64 bit encoded icon string

        Returns:
            A ImageTK PhotoImage
        &#34;&#34;&#34;
        data = Image.open(BytesIO(base64.b64decode(icon_string)))
        img = itk.PhotoImage(data)

        return img

    def _on_load_image(self):
        &#34;&#34;&#34;
        Called when the load image button is chosen


        Returns:
            None

        Postconditions:
            The controllers Image property is set
        &#34;&#34;&#34;
        self._controller.load_new_image()
        self._old_img = None

    def _on_load_mask(self):
        &#34;&#34;&#34;
        Called when the load existing mask button is chosen.


        Returns:
            None
        &#34;&#34;&#34;

        self._controller.load_existing_mask()

    def _on_save_mask(self):
        &#34;&#34;&#34;
        Called when the save mask button is chosen

        Returns:
            None

        Postcondition:
            The controller will be called to save the mask.

        Returns:
            None
        &#34;&#34;&#34;
        self._controller.save_mask()

    def _on_preferences(self):
        &#34;&#34;&#34;
        Called when the preferences menu option is chosen.


        Returns:
            None
        &#34;&#34;&#34;
        PreferencesWindow(self._controller, self.style)

    def _on_about(self):
        &#34;&#34;&#34;
        Called when the about button is chosen.


        Returns:
            None
        &#34;&#34;&#34;
        AboutDialog()

    def _on_keyboard_shortcuts(self):
        &#34;&#34;&#34;
        Called when the keyboard shortcuts button is chosen/


        Returns:
            None
        &#34;&#34;&#34;
        KeyboardShortcutDialog(self._controller.image_tools, self._darkmode)

    def _on_tool_selected(self, id):
        &#34;&#34;&#34;
        Called when a tool is selected in the menubar

        Args:
            id: The id of the tool.

        Returns:
            None

        Postconditions:
            The controller is updated to reflect the current chosen tool.
        &#34;&#34;&#34;
        self._controller.activate_tool(id)
        self._update_toolbar_state(id)

    def _register_key_mappings(self):
        &#34;&#34;&#34;
        Register a mapping of tool ids to keys.


        Returns:
            None

        Postconditions:
            self._key_mappings will contain a dictionary of id -&gt; key mappings
        &#34;&#34;&#34;
        for tool_id in self._controller.image_tools.keys():
            tool = self._controller.image_tools[tool_id]
            self._key_mappings[tool_id] = tool.key_mapping

        for tool_id in self._key_mappings.keys():
            key = self._key_mappings[tool_id]

            self._reverse_key_mappings[key] = tool_id

    def _update_toolbar_state(self, tool_id):
        &#34;&#34;&#34;
        Change the state of the buttons in the toolbar based on the button that
        has been chosen.

        Args:
            tool_id: The id of the tool that was chosen

        Returns:
            None

        Postconditions:
            The toolbar button matching the given id will be activated.
        &#34;&#34;&#34;

        if not self._controller.image_tools[tool_id].persistant:
            return

        for id, button in self._toolbar_buttons.items():
            if id == tool_id and self._controller.image_tools[id].persistant:
                button.state([&#39;disabled&#39;])
            else:
                button.state([&#39;!disabled&#39;])

    def _on_mousewheel(self, event):
        &#34;&#34;&#34;
        Called when the mousewheel is scrolled.

        Args:
            event: The mouse event

        Returns:
            None
        &#34;&#34;&#34;

        # On Linux, the events are different
        if event.num == 4:
            rotation = 120
        elif event.num == 5:
            rotation = -120

        # For Windows and Mac
        if event.delta != 0:
            rotation = event.delta

        # If control is down)
        if event.state - self._previous_state == 4:
            self._controller.adjust_tool(rotation)

    def _set_menubar_theme(self):
        &#34;&#34;&#34;
        Set the theme for the menubar.


        Returns:
            None
        &#34;&#34;&#34;

        background = self.style.lookup(&#39;MenuBar.TMenubutton&#39;, &#39;background&#39;)
        foreground = self.style.lookup(&#39;MenuBar.TMenubutton&#39;, &#39;foreground&#39;)

        activebackground = self.style.lookup(&#39;MenuBar.TMenubutton&#39;,
                                             &#39;activebackground&#39;)
        activeforeground = self.style.lookup(&#39;MenuBar.TMenubutton&#39;,
                                             &#39;activeforeground&#39;)

        self._menubar.config(background=background, foreground=foreground,
                             activebackground=activebackground,
                             activeforeground=activeforeground)

    def _set_filemenu_theme(self):

        background = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;background&#39;)
        foreground = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;foreground&#39;)

        activebackground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activebackground&#39;)
        activeforeground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activeforeground&#39;)

        self._filemenu.config(background=background, foreground=foreground,
                              activebackground=activebackground,
                              activeforeground=activeforeground)

    def _set_viewmenu_theme(self):

        background = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;background&#39;)
        foreground = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;foreground&#39;)

        activebackground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activebackground&#39;)
        activeforeground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activeforeground&#39;)

        self._viewmenu.config(background=background, foreground=foreground,
                              activebackground=activebackground,
                              activeforeground=activeforeground)

        self._previewmenu.config(background=background, foreground=foreground,
                                 activebackground=activebackground,
                                 activeforeground=activeforeground)

    def _set_helpmenu_theme(self):

        background = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;background&#39;)
        foreground = self.style.lookup(&#39;Menu.TMenubutton&#39;, &#39;foreground&#39;)

        activebackground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activebackground&#39;)
        activeforeground = self.style.lookup(&#39;Menu.TMenubutton&#39;,
                                             &#39;activeforeground&#39;)

        self._helpmenu.config(background=background, foreground=foreground,
                              activebackground=activebackground,
                              activeforeground=activeforeground)

    def _set_master_theme(self):
        background = self.style.lookup(&#39;Main.TFrame&#39;, &#39;background&#39;)
        self._master.config(background=background)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Frame</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.view.main_window.MainWindow.create_canvas"><code class="name flex">
<span>def <span class="ident">create_canvas</span></span>(<span>self, image)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the image canvas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>The image, a numpy array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>self._canvas is set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_canvas(self, image):
    &#34;&#34;&#34;
    Create the image canvas.

    Args:
        image: The image, a numpy array.

    Returns:
        None

    Postconditions:
        self._canvas is set
    &#34;&#34;&#34;
    if self._canvas is not None:
        self._canvas.destroy()

    self._canvas = FGTCanvas(self.master, image, self, self.style)
    self._canvas.grid(row=1, column=0, sticky=&#34;NSEW&#34;)

    self._on_preview_setting()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.disable_button"><code class="name flex">
<span>def <span class="ident">disable_button</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable the button with the given id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>The id of the tool whose button to disable.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The button will be in the disabled state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_button(self, id):
    &#34;&#34;&#34;
    Disable the button with the given id.

    Args:
        id: The id of the tool whose button to disable.

    Returns:
        None

    Postconditions:
        The button will be in the disabled state.
    &#34;&#34;&#34;
    self._toolbar_buttons[id].config(state=&#39;disabled&#39;)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.enable_button"><code class="name flex">
<span>def <span class="ident">enable_button</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable the button with the given id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>The id of the tool whose button to enable.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The button will be in the enabled state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_button(self, id):
    &#34;&#34;&#34;
    Enable the button with the given id.

    Args:
        id: The id of the tool whose button to enable.

    Returns:
        None

    Postconditions:
        The button will be in the enabled state.
    &#34;&#34;&#34;
    self._toolbar_buttons[id].config(state=&#39;normal&#39;)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.log_drag_event"><code class="name flex">
<span>def <span class="ident">log_drag_event</span></span>(<span>self, drag_type, start_pos, end_pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_drag_event(self, drag_type, start_pos, end_pos):
    self._controller.log_drag_event(drag_type, start_pos, end_pos)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.log_mouse_event"><code class="name flex">
<span>def <span class="ident">log_mouse_event</span></span>(<span>self, pos, event, button)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_mouse_event(self, pos, event, button):
    self._controller.log_mouse_event(pos, event, button)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.log_zoom_event"><code class="name flex">
<span>def <span class="ident">log_zoom_event</span></span>(<span>self, zoom_factor)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_zoom_event(self, zoom_factor):
    self._controller.log_zoom_event(zoom_factor)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.on_canvas_click"><code class="name flex">
<span>def <span class="ident">on_canvas_click</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the canvas has a click event.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong></dt>
<dd>The position of the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_canvas_click(self, pos):
    &#34;&#34;&#34;
    Called when the canvas has a click event.

    Args:
        pos: The position of the event.

    Returns:
        None
    &#34;&#34;&#34;
    self._controller.click_event(pos)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.on_canvas_drag"><code class="name flex">
<span>def <span class="ident">on_canvas_drag</span></span>(<span>self, pos, drag_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the canvas has a drag event.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong></dt>
<dd>The position of the drag.</dd>
<dt><strong><code>drag_id</code></strong></dt>
<dd>Idenitifier for unique drag events.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_canvas_drag(self, pos, drag_id=None):
    &#34;&#34;&#34;
    Called when the canvas has a drag event.

    Args:
        pos: The position of the drag.
        drag_id: Idenitifier for unique drag events.

    Returns:
        None
    &#34;&#34;&#34;
    self._controller.drag_event(pos, drag_id=drag_id)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.set_canvas_brush_size"><code class="name flex">
<span>def <span class="ident">set_canvas_brush_size</span></span>(<span>self, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the size of the brush in the canvas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>The radius to draw the brush.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The canvas' brush size is changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_canvas_brush_size(self, radius):
    &#34;&#34;&#34;
    Set the size of the brush in the canvas.

    Args:
        radius: The radius to draw the brush.

    Returns:
        None

    Postconditions:
        The canvas&#39; brush size is changed.
    &#34;&#34;&#34;
    self._canvas.brush_radius = radius</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.set_canvas_cursor"><code class="name flex">
<span>def <span class="ident">set_canvas_cursor</span></span>(<span>self, cursor)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the cursor for the canvas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cursor</code></strong></dt>
<dd>The cursor string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The canvas' cursor will be set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_canvas_cursor(self, cursor):
    &#34;&#34;&#34;
    Set the cursor for the canvas.

    Args:
        cursor: The cursor string.

    Returns:
        None

    Postconditions:
        The canvas&#39; cursor will be set.
    &#34;&#34;&#34;
    self._canvas.cursor = cursor</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.set_default_tool"><code class="name flex">
<span>def <span class="ident">set_default_tool</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_tool(self, id):
    self._update_toolbar_state(id)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.set_theme"><code class="name flex">
<span>def <span class="ident">set_theme</span></span>(<span>self, theme)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the current theme for the application.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>theme</code></strong></dt>
<dd>A string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_theme(self, theme):
    &#34;&#34;&#34;
    Set the current theme for the application.

    Args:
        theme: A string.

    Returns:
        None
    &#34;&#34;&#34;

    if theme.lower() == &#39;dark&#39;:
        self._darkmode = True

        from friendly_ground_truth.view import dark_theme

        dark_theme.style.theme_use(&#34;dark_theme&#34;)
        self.style = dark_theme.style

        self._enable_darkmode_buttons()

    elif theme.lower() == &#39;light&#39;:
        self._darkmode = False
        from friendly_ground_truth.view import light_theme

        light_theme.style.theme_use(&#34;light_theme&#34;)
        self.style = light_theme.style

        self._toolbar.destroy()
        self._create_toolbar()

    self._set_menubar_theme()
    self._set_helpmenu_theme()
    self._set_viewmenu_theme()
    self._set_master_theme()
    self._set_filemenu_theme()

    self._canvas.set_theme(self.style)

    if self._preview_window is not None:
        self._preview_window.set_theme(self.style)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.show_image"><code class="name flex">
<span>def <span class="ident">show_image</span></span>(<span>self, img, new=False, patch_offset=(0, 0))</span>
</code></dt>
<dd>
<div class="desc"><p>Display the given image on the canvas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>img</code></strong></dt>
<dd>The image to display, a numpy array</dd>
<dt><strong><code>new</code></strong></dt>
<dd>Whether to reset the canvas for a new image</dd>
<dt><strong><code>patch_offset</code></strong></dt>
<dd>The offset of the current patch in the context image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The canvas's image will be set to the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_image(self, img, new=False, patch_offset=(0, 0)):
    &#34;&#34;&#34;
    Display the given image on the canvas.

    Args:
        img: The image to display, a numpy array
        new: Whether to reset the canvas for a new image
        patch_offset: The offset of the current patch in the context image
    Returns:
        None

    Postconditions:
        The canvas&#39;s image will be set to the image.
    &#34;&#34;&#34;

    if self._canvas is None:
        self.create_canvas(img)
        return
    elif new:
        self._canvas.new_image(img, patch_offset=patch_offset)

        t = threading.Thread(target=self.update_preview, name=&#34;preview&#34;)
        t.daemon = True
        t.start()

    else:

        self._canvas.set_image(img)

        if self._cur_preview_thread is not None:
            self._cur_preview_thread.cancel()

        self._cur_preview_thread = threading.Timer(1.0,
                                                   self.update_preview)
        self._cur_preview_thread.daemon = True
        self._cur_preview_thread.start()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.start_progressbar"><code class="name flex">
<span>def <span class="ident">start_progressbar</span></span>(<span>self, num_patches)</span>
</code></dt>
<dd>
<div class="desc"><p>Start displaying a progressbar.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_patches</code></strong></dt>
<dd>The number of patches that are being loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>A progressbar window is opened and initialized</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_progressbar(self, num_patches):
    &#34;&#34;&#34;
    Start displaying a progressbar.

    Args:
        num_patches: The number of patches that are being loaded.

    Returns:
        None

    Postconditions:
        A progressbar window is opened and initialized
    &#34;&#34;&#34;
    self.progress_popup = tk.Toplevel()
    self.progress_popup.geometry(&#34;100x50+500+400&#34;)

    frame = ttk.Frame(self.progress_popup)

    ttk.Label(frame, text=&#34;Image Loading.&#34;)\
        .grid(row=0, column=0)

    self.load_progress = 0
    self.load_progress_var = tk.DoubleVar()
    self.load_progress_bar = ttk.Progressbar(frame,
                                             variable=self.
                                             load_progress_var,
                                             maximum=100)

    self.load_progress_bar.grid(row=1, column=0, sticky=&#34;NSEW&#34;)

    self.progress_step = float(100.0/num_patches)

    frame.grid(row=0, column=0, sticky=&#34;NSEW&#34;)
    self.progress_popup.grid_columnconfigure(0, weight=1)

    self.progress_popup.pack_slaves()

    background = self.style.lookup(&#34;TFrame&#34;, &#34;background&#34;)
    self.progress_popup.config(background=background)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.update_canvas_image"><code class="name flex">
<span>def <span class="ident">update_canvas_image</span></span>(<span>self, image)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the current image in the canvas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>The image, a numpy array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The canvas's image will be set to the given image data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_canvas_image(self, image):
    &#34;&#34;&#34;
    Set the current image in the canvas.

    Args:
        image: The image, a numpy array

    Returns:
        None

    Postconditions:
        The canvas&#39;s image will be set to the given image data.
    &#34;&#34;&#34;
    if self._canvas is not None:
        self._canvas.img = image</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.update_image_indicator"><code class="name flex">
<span>def <span class="ident">update_image_indicator</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the image indicator in the toolbar with the given text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>The text to display in the toolbar.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The text in the toolbar will display the given text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_image_indicator(self, text):
    &#34;&#34;&#34;
    Update the image indicator in the toolbar with the given text.

    Args:
        text: The text to display in the toolbar.

    Returns:
        None

    Postconditions:
        The text in the toolbar will display the given text.
    &#34;&#34;&#34;
    self._image_indicator.config(text=text)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.update_info_panel"><code class="name flex">
<span>def <span class="ident">update_info_panel</span></span>(<span>self, tool)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the info panel with the activated tool's widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tool</code></strong></dt>
<dd>The tool that the info panel should represent.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The info panel will display the widget defined by the tool.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_info_panel(self, tool):
    &#34;&#34;&#34;
    Update the info panel with the activated tool&#39;s widget.

    Args:
        tool: The tool that the info panel should represent.

    Returns:
        None

    Postconditions:
        The info panel will display the widget defined by the tool.
    &#34;&#34;&#34;
    tool.lock_undos()
    if self._old_tool is not None:
        self._old_tool.destroy_info_widget()

    self._info_panel.set_info_widget(tool.
                                     get_info_widget(self._info_panel,
                                                     self.style),
                                     tool.name)

    self._old_tool = tool</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.view.main_window.MainWindow.update_preview"><code class="name flex">
<span>def <span class="ident">update_preview</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_preview(self):

    if self._preview_window is not None:
        img = self._controller.get_image_preview()

        self._preview_window.update_image(img)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="friendly_ground_truth.view" href="index.html">friendly_ground_truth.view</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="friendly_ground_truth.view.main_window.CreateToolTip" href="#friendly_ground_truth.view.main_window.CreateToolTip">CreateToolTip</a></code></h4>
<ul class="two-column">
<li><code><a title="friendly_ground_truth.view.main_window.CreateToolTip.enter" href="#friendly_ground_truth.view.main_window.CreateToolTip.enter">enter</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.CreateToolTip.hidetip" href="#friendly_ground_truth.view.main_window.CreateToolTip.hidetip">hidetip</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.CreateToolTip.leave" href="#friendly_ground_truth.view.main_window.CreateToolTip.leave">leave</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.CreateToolTip.schedule" href="#friendly_ground_truth.view.main_window.CreateToolTip.schedule">schedule</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.CreateToolTip.showtip" href="#friendly_ground_truth.view.main_window.CreateToolTip.showtip">showtip</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.CreateToolTip.unschedule" href="#friendly_ground_truth.view.main_window.CreateToolTip.unschedule">unschedule</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="friendly_ground_truth.view.main_window.MainWindow" href="#friendly_ground_truth.view.main_window.MainWindow">MainWindow</a></code></h4>
<ul class="">
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.create_canvas" href="#friendly_ground_truth.view.main_window.MainWindow.create_canvas">create_canvas</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.disable_button" href="#friendly_ground_truth.view.main_window.MainWindow.disable_button">disable_button</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.enable_button" href="#friendly_ground_truth.view.main_window.MainWindow.enable_button">enable_button</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.log_drag_event" href="#friendly_ground_truth.view.main_window.MainWindow.log_drag_event">log_drag_event</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.log_mouse_event" href="#friendly_ground_truth.view.main_window.MainWindow.log_mouse_event">log_mouse_event</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.log_zoom_event" href="#friendly_ground_truth.view.main_window.MainWindow.log_zoom_event">log_zoom_event</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.on_canvas_click" href="#friendly_ground_truth.view.main_window.MainWindow.on_canvas_click">on_canvas_click</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.on_canvas_drag" href="#friendly_ground_truth.view.main_window.MainWindow.on_canvas_drag">on_canvas_drag</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.set_canvas_brush_size" href="#friendly_ground_truth.view.main_window.MainWindow.set_canvas_brush_size">set_canvas_brush_size</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.set_canvas_cursor" href="#friendly_ground_truth.view.main_window.MainWindow.set_canvas_cursor">set_canvas_cursor</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.set_default_tool" href="#friendly_ground_truth.view.main_window.MainWindow.set_default_tool">set_default_tool</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.set_theme" href="#friendly_ground_truth.view.main_window.MainWindow.set_theme">set_theme</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.show_image" href="#friendly_ground_truth.view.main_window.MainWindow.show_image">show_image</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.start_progressbar" href="#friendly_ground_truth.view.main_window.MainWindow.start_progressbar">start_progressbar</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.update_canvas_image" href="#friendly_ground_truth.view.main_window.MainWindow.update_canvas_image">update_canvas_image</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.update_image_indicator" href="#friendly_ground_truth.view.main_window.MainWindow.update_image_indicator">update_image_indicator</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.update_info_panel" href="#friendly_ground_truth.view.main_window.MainWindow.update_info_panel">update_info_panel</a></code></li>
<li><code><a title="friendly_ground_truth.view.main_window.MainWindow.update_preview" href="#friendly_ground_truth.view.main_window.MainWindow.update_preview">update_preview</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>