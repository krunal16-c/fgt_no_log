<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>friendly_ground_truth.model.model API documentation</title>
<meta name="description" content="File Name: model.py â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>friendly_ground_truth.model.model</code></h1>
</header>
<section id="section-intro">
<p>File Name: model.py</p>
<p>Authors: Kyle Seidenthal</p>
<p>Date: 11-05-2020</p>
<p>Description: Model Classes</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
File Name: model.py

Authors: Kyle Seidenthal

Date: 11-05-2020

Description: Model Classes

&#34;&#34;&#34;
import logging
import numpy as np

from skimage import io, img_as_float, img_as_uint, img_as_ubyte, img_as_bool
from skimage.util.shape import view_as_blocks
from skimage.filters import threshold_otsu
from skimage import color
from skimage.draw import circle


module_logger = logging.getLogger(&#39;friendly_gt.model&#39;)


class Image():
    &#34;&#34;&#34;
    Represents a loaded image

    Attributes:
        path: The path to the image
        num_patches: The number of patches in a row
        image: The image array
        mask: The complete image mask
        patches: The list of Patches for this image
    &#34;&#34;&#34;

    BG_LABEL = 0
    TIP_LABEL = 1
    BRANCH_LABEL = 2
    CROSS_LABEL = 3

    def __init__(self, path, num_patches=10, progress_update_func=None):
        &#34;&#34;&#34;
        Initialize an image

        Args:
            path: The path to the image to load
            num_patches: The number of patches per row and column
                         (sqrt(total_patches))
            progress_update_func: A function used when updating a loading
                                  progress bar  The default value is None.

        Returns:
            An image object
        &#34;&#34;&#34;
        self.logger = logging.getLogger(&#39;friendly_gt.model.Image&#39;)

        if num_patches &lt;= 0:
            raise ValueError(&#34;num_patches must be a positive integer&#34;)

        self._path = path
        self._num_patches = num_patches
        self._progress_update_func = progress_update_func

        self._load_image()
        self._create_patches()

    @property
    def path(self):
        &#34;&#34;&#34;
        Represents the path to the image file.


        Returns:
            The path to the image file.
        &#34;&#34;&#34;
        return self._path

    @property
    def num_patches(self):
        &#34;&#34;&#34;
        The number of patches to split each row into.


        Returns:
            The number of patches each row should be split into.
        &#34;&#34;&#34;
        return self._num_patches

    @property
    def image(self):
        &#34;&#34;&#34;
        The image data.


        Returns:
            The image data, a numpy array.
        &#34;&#34;&#34;
        return self._image

    @property
    def mask(self):
        &#34;&#34;&#34;
        The mask for the whole image.


        Returns:
            A boolean numpy array representing the image mask.
        &#34;&#34;&#34;
        self._create_mask()
        return self._mask

    @property
    def patches(self):
        &#34;&#34;&#34;
        A list of the patches for this image.


        Returns:
            A list of Patch objects.
        &#34;&#34;&#34;
        return self._patches

    def _load_image(self):
        &#34;&#34;&#34;
        Load the image associated with this instance

        Returns:
            None

        Postconditions:
            self._image and self_mask will be initialized
        &#34;&#34;&#34;
        self.logger.debug(&#34;Loading image.&#34;)

        img = io.imread(self.path)
        img = color.rgb2gray(img)
        img = img_as_float(img)

        self._image = img
        self._mask = np.zeros(self._image.shape, dtype=bool)

    def load_mask(self, path):
        &#34;&#34;&#34;
        Load a saved mask for the current image.

        Args:
            path: The path to the mask file.

        Returns:
            None
        &#34;&#34;&#34;
        # Load the mask
        mask = io.imread(path)
        mask = img_as_bool(mask)

        self._mask = mask

        # Figure out padding
        pad_x = (0, 0)
        pad_y = (0, 0)

        if mask.shape[0] % self.num_patches != 0:
            pad_x = (0, (self.num_patches - (mask.shape[0] %
                     self.num_patches)))

        if mask.shape[1] % self.num_patches != 0:
            pad_y = (0, (self.num_patches - (mask.shape[1] %
                     self.num_patches)))
        mask = np.pad(mask, (pad_x, pad_y), &#39;constant&#39;,
                      constant_values=(0, 0))

        # Split into blocks
        blocks = view_as_blocks(mask, block_shape=self._block_size)

        for i in range(self.num_patches):
            for j in range(self.num_patches):
                patch_data = blocks[i, j]

                self._patches[(i * self.num_patches) + j].mask = patch_data
                self._patches[(i * self.num_patches) + j]._overlay_mask()

                if self._progress_update_func is not None:
                    self._progress_update_func()

    def _create_patches(self):
        &#34;&#34;&#34;
        Create a list of patches from the image

        Returns:
            None

        Postconditions:
            self._patches will be set to a list of Patch objects
        &#34;&#34;&#34;

        self.logger.debug(&#34;Creating patches.&#34;)

        # Determine padding so we can use non-overlapping patches
        pad_x = (0, 0)
        pad_y = (0, 0)

        if self.image.shape[0] % self.num_patches != 0:
            pad_x = (0, (self.num_patches - (self.image.shape[0] %
                     self.num_patches)))

        if self.image.shape[1] % self.num_patches != 0:
            pad_y = (0, (self.num_patches - (self.image.shape[1] %
                     self.num_patches)))
        image = np.pad(self.image, (pad_x, pad_y), &#39;constant&#39;,
                       constant_values=(0, 0))

        self._padded_shape = image.shape

        block_size = (image.shape[0]//self.num_patches,
                      image.shape[1]//self.num_patches)

        self._block_size = block_size

        # Make the blocks
        blocks = view_as_blocks(image, block_shape=block_size)

        patches = []

        for i in range(self.num_patches):
            for j in range(self.num_patches):
                patch_data = blocks[i, j]
                patches.append(Patch(patch_data, (i, j)))

                if self._progress_update_func is not None:
                    self._progress_update_func()

        self._patches = patches

    def get_patch_from_coords(self, coords):
        &#34;&#34;&#34;
        Get the index of the patch that contains the given coordinates.

        Args:
            coords: Coordinates in the original image.

        Returns:
            The index into the patches list of the corresponding patch.
        &#34;&#34;&#34;

        row = int(coords[0]/self._block_size[0])
        col = int(coords[1]/self._block_size[1])

        return row * self.num_patches + col

    def _create_mask(self):
        &#34;&#34;&#34;
        Take the masks from all the patches and combine them into the mask for
        the whole image.


        Returns:
            None

        Postconditions:
            self._mask will be set to the combined mask
        &#34;&#34;&#34;

        mask = np.zeros(self._padded_shape, dtype=bool)

        for patch in self.patches:
            r, c = patch.patch_index
            r = r * patch.patch.shape[0]
            c = c * patch.patch.shape[1]

            mask[r:r+patch.patch.shape[0],
                 c:c+patch.patch.shape[1]] += patch.mask

        self._mask = mask[:self.image.shape[0], :self.image.shape[1]]

    def create_overlay_img(self):
        &#34;&#34;&#34;
        Create an overlay image using the mask.


        Returns:
            The image
        &#34;&#34;&#34;
        shape = self._padded_shape[0], self._padded_shape[1], 3
        img = np.zeros(shape, dtype=self.patches[0].overlay_image.dtype)

        for patch in self.patches:
            r, c = patch.patch_index
            r = r * patch.patch.shape[0]
            c = c * patch.patch.shape[1]

            img[r:r+patch.patch.shape[0],
                c:c+patch.patch.shape[1], :] = patch.overlay_image

        return img[:self.image.shape[0], :self.image.shape[1], :]

    def _create_labelling(self):
        &#34;&#34;&#34;
        Take the labellings from all patches and combine them into one matrix


        Returns:
            None

        Postconditions:
            self._landmark_matrix will be set
        &#34;&#34;&#34;

        labels = np.zeros(self._padded_shape, dtype=np.uint8)

        for patch in self.patches:
            r, c = patch.patch_index
            r = r * patch.patch.shape[0]
            c = c * patch.patch.shape[1]

            labels[r:r+patch.patch.shape[0],
                   c:c+patch.patch.shape[1]] += patch.landmark_labels

        self._landmark_matrix = labels[:self.image.shape[0],
                                       :self.image.shape[1]]

    def export_mask(self, pathname):
        &#34;&#34;&#34;
        Export the patch masks as a whole image mask

        Args:
            pathname: The path to the mask image file to save as.

        Returns:
            None

        Postconditions:
            A PNG image representing the mask will be saved at the
            specified path.
        &#34;&#34;&#34;
        self._create_mask()

        # backup_path = os.path.splitext(pathname)[0]
        # backup_path += &#34;_bak.png&#34;
        # io.imsave(backup_path, img_as_uint(self.mask))

        # self._remove_small_components()
        io.imsave(pathname, img_as_uint(self.mask))

    def export_labels(self, pathname):
        &#34;&#34;&#34;
        Export the labelling matrix

        Args:
            pathname: The path to the labelling matrix file

        Returns:
            None

        Postconditions:
            a .npy file will be saved at the specified path
        &#34;&#34;&#34;

        self._create_labelling()
        np.save(pathname, self._landmark_matrix)

    def _remove_small_components(self):
        &#34;&#34;&#34;
        Remove components that are not connected to the main root.


        Returns:
            None

        Postconditions:
            self._mask will be updated with the cleaned mask
        &#34;&#34;&#34;
        from skimage.measure import label

        labels = label(self._mask)
        largestCC = labels == np.argmax(np.bincount(labels.flat)[1:])+1
        self._mask = largestCC


class Patch():
    &#34;&#34;&#34;
    Represents an image patch

    Attributes:
        threshold: The current threshold for the mask
        patch: The patch image data
        mask: The mask for the patch
        patch_index: The index of this patch in the original image
        overlay_image: The patch image with the mask overlaid on top
        undo_history: The undo history for this patch
    &#34;&#34;&#34;

    def __init__(self, patch, patch_index):
        &#34;&#34;&#34;
        Create a patch object

        Args:
            patch: The image data for the patch
            patch_index: The index in the larger image of this patch

        Returns:
            A Patch object
        &#34;&#34;&#34;

        self._logger = logging.getLogger(&#39;friendly_gt.model.Patch&#39;)

        self._patch = patch
        self._mask = np.zeros(self._patch.shape, dtype=bool)
        self._landmark_labels = np.zeros(self._patch.shape, dtype=np.uint8)

        self._patch_index = patch_index

        self._threshold = 1

        try:
            self.threshold = threshold_otsu(self._patch)
        except ValueError:
            self.threshold = 1

        self._overlay_image = None
        self._overlay_mask()

        self._old_flood_add_tolerance = 100
        self._old_flood_add_position = None

        self._old_flood_remove_tolerance = 100
        self._old_flood_remove_position = None

        self._undo_history = None

    @property
    def threshold(self):
        &#34;&#34;&#34;
        The current threshold value for the patch.


        Returns:
            The value of the current threshold.
        &#34;&#34;&#34;
        return self._threshold

    @threshold.setter
    def threshold(self, value):
        &#34;&#34;&#34;
        Set the threshold for this patch.

        Args:
            value: The value to set the threshold to.

        Returns:
            None

        Postconditions:
            The threshold will be applied to the mask.
            The overlay_image property will be updated to show the new mask.
        &#34;&#34;&#34;

        if value &gt;= 0 and value &lt;= 1:

            self._threshold = value
            self._apply_threshold(value)
            self._overlay_mask()

    @property
    def patch(self):
        &#34;&#34;&#34;
        The patch data for this patch.


        Returns:
            A numpy array representing the image data for this patch.
        &#34;&#34;&#34;
        return self._patch

    @property
    def mask(self):
        &#34;&#34;&#34;
        The current mask for this patch.


        Returns:
            A numpy array representing the mask for this patch.
        &#34;&#34;&#34;
        return self._mask

    @mask.setter
    def mask(self, mask):
        &#34;&#34;&#34;
        Set the mask.

        Args:
            mask: The new mask, a boolean numpy array.

        Returns:
            None
        &#34;&#34;&#34;
        self._mask = mask

    @property
    def landmark_labels(self):
        &#34;&#34;&#34;
        The landmark label matrix for this patch.


        Returns:
            A numpy array containing class labellings for pixels in this patch.
        &#34;&#34;&#34;
        return self._landmark_labels

    @property
    def patch_index(self):
        &#34;&#34;&#34;
        The index of this patch in the larger parent image matrix.


        Returns:
            A tuple (i, j), the row and column index for this patch.
        &#34;&#34;&#34;
        return self._patch_index

    @property
    def overlay_image(self):
        &#34;&#34;&#34;
        The overlay image displaying the mask on top of the patch image data.


        Returns:
            A numpy array colour image.
        &#34;&#34;&#34;
        return self._overlay_image

    @property
    def undo_history(self):
        return self._undo_history

    @undo_history.setter
    def undo_history(self, history):
        self._undo_history = history

    def _apply_threshold(self, value):
        &#34;&#34;&#34;
        Apply a threshold to the patch mask

        Args:
            value: The value for the threshold

        Returns:
            None

        Postconditions:
            The _mask property will be updated with the new threshold
            applied

        Raises:
            ValueError if the value is not between 0 and 1
        &#34;&#34;&#34;

        if value &gt; 1 or value &lt; 0:
            raise ValueError(&#34;Threshold values must be between 0 and 1&#34;)

        binary = self.patch &gt; value
        self._mask = binary

    def _overlay_mask(self):
        &#34;&#34;&#34;
        Overlay the current mask on the patch image


        Returns:
            None

        Postconditions:
            The _overlay_image property will contain the image with the
            binary mask over top.
        &#34;&#34;&#34;

        labeling = np.copy(self._landmark_labels)
        labeling += self.mask

        c1 = &#39;red&#39;
        c2 = &#39;green&#39;
        c3 = &#39;orange&#39;
        c4 = &#39;blue&#39;

        colours = []
        unique_labels = np.unique(labeling)

        mapping = [(1, c1), (2, c2), (3, c3), (4, c4)]

        for m in mapping:
            if m[0] in unique_labels:
                colours.append(m[1])

        if len(colours) &lt;= 0:
            colours = [&#39;purple&#39;]

        colour_mask = color.label2rgb(labeling, image=self._patch,
                                      colors=colours, bg_label=0)

        self._overlay_image = img_as_ubyte(colour_mask)

    def clear_mask(self):
        &#34;&#34;&#34;
        Clear the mask for this patch (set to all 0&#39;s)


        Returns:
            None

        Postconditions:
            The mask property will be reset to all 0&#39;s
        &#34;&#34;&#34;
        self._mask = np.zeros(self.patch.shape, dtype=bool)
        self.threshold = 1

    def add_landmark(self, position, radius, label):
        &#34;&#34;&#34;
        Label an area with the given label

        Args:
            position: The position to add the labelling (x, y)
            radius: The radius of a circle to label
            label: The class label for the pixels to be given

        Returns:
            None

        Postconditions:
            The _landmark_labels property will be udpated with the new
            landmark annotation.
        &#34;&#34;&#34;
        rr, cc = self._get_circle(position, radius)

        self._landmark_labels[rr, cc] = label

        # Don&#39;t mark anything that isn&#39;t foreground
        self._landmark_labels[self.mask == 0] = 0
        self._overlay_mask()

    def remove_landmark(self, position, radius):
        &#34;&#34;&#34;
        Un-label (label as 0) the pixels in the given region.


        Args:
            position: The position to un-label (x, y)
            radius: The radius of a circle to un-label

        Returns:
            None

        Postconditions:
            The _landmark_labels property will be updated with the new
            annotation.
        &#34;&#34;&#34;

        rr, cc = self._get_circle(position, radius)

        self._landmark_labels[rr, cc] = 0

        self._overlay_mask()

    def add_region(self, position, radius):
        &#34;&#34;&#34;
        Add a circular region to the mask at the given position.

        Args:
            position: The position to add the region (x, y)
            radius: The radius of the circular region

        Returns:
            None

        Postconditions:
            The _mask will be updated with the circular region set to 1&#39;s
        &#34;&#34;&#34;

        position = round(position[0]), round(position[1])

        self._logger.debug(&#34;Add Position: {}&#34;.format(position))
        rr, cc = self._get_circle(position, radius)

        self._mask[rr, cc] = 1

        self._overlay_mask()

    def remove_region(self, position, radius):
        &#34;&#34;&#34;
        Remove a circular region from the mask at the given position.

        Args:
            position: The position to remove the region at (x, y)
            radius: The radius of the circular region

        Returns:
            None

        Postconditions:
            The _mask will be updated with the circular region set to 0&#39;s
        &#34;&#34;&#34;
        rr, cc = self._get_circle(position, radius)

        self._mask[rr, cc] = 0

        self._overlay_mask()

    def flood_add_region(self, position, tolerance):
        &#34;&#34;&#34;
        Add to the current mask a flood region at the given position with the
        given tolerance.


        Args:
            position: The position to start the flood fill (x, y)
            tolerance: The tolerance for pixels to be included

        Returns:
            None

        Postconditions:
            The _mask will be updated with the new region.
        &#34;&#34;&#34;

        from skimage.segmentation import flood

        position = int(position[0]), int(position[1])

        # If we are still editing the tolerance, we need to go back to the old
        # mask.
        if position == self._old_flood_add_position:
            self.mask = np.copy(self._old_mask)
        else:
            self._old_mask = np.copy(self._mask)

        add_mask = flood(self._patch, position, tolerance=tolerance)

        self._mask += add_mask

        self._overlay_mask()

        self._old_flood_add_tolerance = tolerance
        self._old_flood_add_position = position

    def flood_remove_region(self, position, tolerance):
        &#34;&#34;&#34;
        Remove from the current mask a flood region at the given position with
        the given tolerance.

        Args:
            position: The position to start the flood fill (x, y)
            tolerance: The tolerance for pixels to be included

        Returns:
            None

        Postconditions:
            The _mask will be updated with the new region
        &#34;&#34;&#34;
        from skimage.segmentation import flood

        position = int(position[0]), int(position[1])

        # If we are still editing the tolerance, we need to go back to the old
        # mask.
        if position == self._old_flood_remove_position:
            self.mask = np.copy(self._old_mask)
        else:
            self._old_mask = np.copy(self._mask)

        remove_mask = flood(self._patch, position, tolerance=tolerance)

        self._mask[remove_mask] = 0

        self._overlay_mask()

        self._old_flood_remove_tolerance = tolerance
        self._old_flood_remove_position = position

    def _get_circle(self, position, radius):
        &#34;&#34;&#34;
        Return the indices of a circular region at the given position with the
        given radius.

        Args:
            position: (x, y) coordinates of the circle
            radius: The radius of the circle

        Returns:
            Two lists, rr and cc that represnt points in the circle
        &#34;&#34;&#34;

        rr, cc = circle(position[0], position[1], radius)

        zipped = zip(rr, cc)

        fixed_pairs = []

        for pair in zipped:
            if (pair[0] &gt;= 0 and pair[1] &gt;= 0 and pair[0] &lt; self._mask.shape[0]
                    and pair[1] &lt; self.mask.shape[1]):
                fixed_pairs.append(pair)

        rr = []
        cc = []

        for p in fixed_pairs:
            rr.append(p[0])
            cc.append(p[1])

        return rr, cc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="friendly_ground_truth.model.model.Image"><code class="flex name class">
<span>class <span class="ident">Image</span></span>
<span>(</span><span>path, num_patches=10, progress_update_func=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a loaded image</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The path to the image</dd>
<dt><strong><code>num_patches</code></strong></dt>
<dd>The number of patches in a row</dd>
<dt><strong><code>image</code></strong></dt>
<dd>The image array</dd>
<dt><strong><code>mask</code></strong></dt>
<dd>The complete image mask</dd>
<dt><strong><code>patches</code></strong></dt>
<dd>The list of Patches for this image</dd>
</dl>
<p>Initialize an image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The path to the image to load</dd>
<dt><strong><code>num_patches</code></strong></dt>
<dd>The number of patches per row and column
(sqrt(total_patches))</dd>
<dt><strong><code>progress_update_func</code></strong></dt>
<dd>A function used when updating a loading
progress bar
The default value is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An image object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Image():
    &#34;&#34;&#34;
    Represents a loaded image

    Attributes:
        path: The path to the image
        num_patches: The number of patches in a row
        image: The image array
        mask: The complete image mask
        patches: The list of Patches for this image
    &#34;&#34;&#34;

    BG_LABEL = 0
    TIP_LABEL = 1
    BRANCH_LABEL = 2
    CROSS_LABEL = 3

    def __init__(self, path, num_patches=10, progress_update_func=None):
        &#34;&#34;&#34;
        Initialize an image

        Args:
            path: The path to the image to load
            num_patches: The number of patches per row and column
                         (sqrt(total_patches))
            progress_update_func: A function used when updating a loading
                                  progress bar  The default value is None.

        Returns:
            An image object
        &#34;&#34;&#34;
        self.logger = logging.getLogger(&#39;friendly_gt.model.Image&#39;)

        if num_patches &lt;= 0:
            raise ValueError(&#34;num_patches must be a positive integer&#34;)

        self._path = path
        self._num_patches = num_patches
        self._progress_update_func = progress_update_func

        self._load_image()
        self._create_patches()

    @property
    def path(self):
        &#34;&#34;&#34;
        Represents the path to the image file.


        Returns:
            The path to the image file.
        &#34;&#34;&#34;
        return self._path

    @property
    def num_patches(self):
        &#34;&#34;&#34;
        The number of patches to split each row into.


        Returns:
            The number of patches each row should be split into.
        &#34;&#34;&#34;
        return self._num_patches

    @property
    def image(self):
        &#34;&#34;&#34;
        The image data.


        Returns:
            The image data, a numpy array.
        &#34;&#34;&#34;
        return self._image

    @property
    def mask(self):
        &#34;&#34;&#34;
        The mask for the whole image.


        Returns:
            A boolean numpy array representing the image mask.
        &#34;&#34;&#34;
        self._create_mask()
        return self._mask

    @property
    def patches(self):
        &#34;&#34;&#34;
        A list of the patches for this image.


        Returns:
            A list of Patch objects.
        &#34;&#34;&#34;
        return self._patches

    def _load_image(self):
        &#34;&#34;&#34;
        Load the image associated with this instance

        Returns:
            None

        Postconditions:
            self._image and self_mask will be initialized
        &#34;&#34;&#34;
        self.logger.debug(&#34;Loading image.&#34;)

        img = io.imread(self.path)
        img = color.rgb2gray(img)
        img = img_as_float(img)

        self._image = img
        self._mask = np.zeros(self._image.shape, dtype=bool)

    def load_mask(self, path):
        &#34;&#34;&#34;
        Load a saved mask for the current image.

        Args:
            path: The path to the mask file.

        Returns:
            None
        &#34;&#34;&#34;
        # Load the mask
        mask = io.imread(path)
        mask = img_as_bool(mask)

        self._mask = mask

        # Figure out padding
        pad_x = (0, 0)
        pad_y = (0, 0)

        if mask.shape[0] % self.num_patches != 0:
            pad_x = (0, (self.num_patches - (mask.shape[0] %
                     self.num_patches)))

        if mask.shape[1] % self.num_patches != 0:
            pad_y = (0, (self.num_patches - (mask.shape[1] %
                     self.num_patches)))
        mask = np.pad(mask, (pad_x, pad_y), &#39;constant&#39;,
                      constant_values=(0, 0))

        # Split into blocks
        blocks = view_as_blocks(mask, block_shape=self._block_size)

        for i in range(self.num_patches):
            for j in range(self.num_patches):
                patch_data = blocks[i, j]

                self._patches[(i * self.num_patches) + j].mask = patch_data
                self._patches[(i * self.num_patches) + j]._overlay_mask()

                if self._progress_update_func is not None:
                    self._progress_update_func()

    def _create_patches(self):
        &#34;&#34;&#34;
        Create a list of patches from the image

        Returns:
            None

        Postconditions:
            self._patches will be set to a list of Patch objects
        &#34;&#34;&#34;

        self.logger.debug(&#34;Creating patches.&#34;)

        # Determine padding so we can use non-overlapping patches
        pad_x = (0, 0)
        pad_y = (0, 0)

        if self.image.shape[0] % self.num_patches != 0:
            pad_x = (0, (self.num_patches - (self.image.shape[0] %
                     self.num_patches)))

        if self.image.shape[1] % self.num_patches != 0:
            pad_y = (0, (self.num_patches - (self.image.shape[1] %
                     self.num_patches)))
        image = np.pad(self.image, (pad_x, pad_y), &#39;constant&#39;,
                       constant_values=(0, 0))

        self._padded_shape = image.shape

        block_size = (image.shape[0]//self.num_patches,
                      image.shape[1]//self.num_patches)

        self._block_size = block_size

        # Make the blocks
        blocks = view_as_blocks(image, block_shape=block_size)

        patches = []

        for i in range(self.num_patches):
            for j in range(self.num_patches):
                patch_data = blocks[i, j]
                patches.append(Patch(patch_data, (i, j)))

                if self._progress_update_func is not None:
                    self._progress_update_func()

        self._patches = patches

    def get_patch_from_coords(self, coords):
        &#34;&#34;&#34;
        Get the index of the patch that contains the given coordinates.

        Args:
            coords: Coordinates in the original image.

        Returns:
            The index into the patches list of the corresponding patch.
        &#34;&#34;&#34;

        row = int(coords[0]/self._block_size[0])
        col = int(coords[1]/self._block_size[1])

        return row * self.num_patches + col

    def _create_mask(self):
        &#34;&#34;&#34;
        Take the masks from all the patches and combine them into the mask for
        the whole image.


        Returns:
            None

        Postconditions:
            self._mask will be set to the combined mask
        &#34;&#34;&#34;

        mask = np.zeros(self._padded_shape, dtype=bool)

        for patch in self.patches:
            r, c = patch.patch_index
            r = r * patch.patch.shape[0]
            c = c * patch.patch.shape[1]

            mask[r:r+patch.patch.shape[0],
                 c:c+patch.patch.shape[1]] += patch.mask

        self._mask = mask[:self.image.shape[0], :self.image.shape[1]]

    def create_overlay_img(self):
        &#34;&#34;&#34;
        Create an overlay image using the mask.


        Returns:
            The image
        &#34;&#34;&#34;
        shape = self._padded_shape[0], self._padded_shape[1], 3
        img = np.zeros(shape, dtype=self.patches[0].overlay_image.dtype)

        for patch in self.patches:
            r, c = patch.patch_index
            r = r * patch.patch.shape[0]
            c = c * patch.patch.shape[1]

            img[r:r+patch.patch.shape[0],
                c:c+patch.patch.shape[1], :] = patch.overlay_image

        return img[:self.image.shape[0], :self.image.shape[1], :]

    def _create_labelling(self):
        &#34;&#34;&#34;
        Take the labellings from all patches and combine them into one matrix


        Returns:
            None

        Postconditions:
            self._landmark_matrix will be set
        &#34;&#34;&#34;

        labels = np.zeros(self._padded_shape, dtype=np.uint8)

        for patch in self.patches:
            r, c = patch.patch_index
            r = r * patch.patch.shape[0]
            c = c * patch.patch.shape[1]

            labels[r:r+patch.patch.shape[0],
                   c:c+patch.patch.shape[1]] += patch.landmark_labels

        self._landmark_matrix = labels[:self.image.shape[0],
                                       :self.image.shape[1]]

    def export_mask(self, pathname):
        &#34;&#34;&#34;
        Export the patch masks as a whole image mask

        Args:
            pathname: The path to the mask image file to save as.

        Returns:
            None

        Postconditions:
            A PNG image representing the mask will be saved at the
            specified path.
        &#34;&#34;&#34;
        self._create_mask()

        # backup_path = os.path.splitext(pathname)[0]
        # backup_path += &#34;_bak.png&#34;
        # io.imsave(backup_path, img_as_uint(self.mask))

        # self._remove_small_components()
        io.imsave(pathname, img_as_uint(self.mask))

    def export_labels(self, pathname):
        &#34;&#34;&#34;
        Export the labelling matrix

        Args:
            pathname: The path to the labelling matrix file

        Returns:
            None

        Postconditions:
            a .npy file will be saved at the specified path
        &#34;&#34;&#34;

        self._create_labelling()
        np.save(pathname, self._landmark_matrix)

    def _remove_small_components(self):
        &#34;&#34;&#34;
        Remove components that are not connected to the main root.


        Returns:
            None

        Postconditions:
            self._mask will be updated with the cleaned mask
        &#34;&#34;&#34;
        from skimage.measure import label

        labels = label(self._mask)
        largestCC = labels == np.argmax(np.bincount(labels.flat)[1:])+1
        self._mask = largestCC</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="friendly_ground_truth.model.model.Image.BG_LABEL"><code class="name">var <span class="ident">BG_LABEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.model.model.Image.BRANCH_LABEL"><code class="name">var <span class="ident">BRANCH_LABEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.model.model.Image.CROSS_LABEL"><code class="name">var <span class="ident">CROSS_LABEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.model.model.Image.TIP_LABEL"><code class="name">var <span class="ident">TIP_LABEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="friendly_ground_truth.model.model.Image.image"><code class="name">var <span class="ident">image</span></code></dt>
<dd>
<div class="desc"><p>The image data.</p>
<h2 id="returns">Returns</h2>
<p>The image data, a numpy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def image(self):
    &#34;&#34;&#34;
    The image data.


    Returns:
        The image data, a numpy array.
    &#34;&#34;&#34;
    return self._image</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Image.mask"><code class="name">var <span class="ident">mask</span></code></dt>
<dd>
<div class="desc"><p>The mask for the whole image.</p>
<h2 id="returns">Returns</h2>
<p>A boolean numpy array representing the image mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mask(self):
    &#34;&#34;&#34;
    The mask for the whole image.


    Returns:
        A boolean numpy array representing the image mask.
    &#34;&#34;&#34;
    self._create_mask()
    return self._mask</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Image.num_patches"><code class="name">var <span class="ident">num_patches</span></code></dt>
<dd>
<div class="desc"><p>The number of patches to split each row into.</p>
<h2 id="returns">Returns</h2>
<p>The number of patches each row should be split into.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_patches(self):
    &#34;&#34;&#34;
    The number of patches to split each row into.


    Returns:
        The number of patches each row should be split into.
    &#34;&#34;&#34;
    return self._num_patches</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Image.patches"><code class="name">var <span class="ident">patches</span></code></dt>
<dd>
<div class="desc"><p>A list of the patches for this image.</p>
<h2 id="returns">Returns</h2>
<p>A list of Patch objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def patches(self):
    &#34;&#34;&#34;
    A list of the patches for this image.


    Returns:
        A list of Patch objects.
    &#34;&#34;&#34;
    return self._patches</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Image.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><p>Represents the path to the image file.</p>
<h2 id="returns">Returns</h2>
<p>The path to the image file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self):
    &#34;&#34;&#34;
    Represents the path to the image file.


    Returns:
        The path to the image file.
    &#34;&#34;&#34;
    return self._path</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.model.model.Image.create_overlay_img"><code class="name flex">
<span>def <span class="ident">create_overlay_img</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an overlay image using the mask.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The image</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_overlay_img(self):
    &#34;&#34;&#34;
    Create an overlay image using the mask.


    Returns:
        The image
    &#34;&#34;&#34;
    shape = self._padded_shape[0], self._padded_shape[1], 3
    img = np.zeros(shape, dtype=self.patches[0].overlay_image.dtype)

    for patch in self.patches:
        r, c = patch.patch_index
        r = r * patch.patch.shape[0]
        c = c * patch.patch.shape[1]

        img[r:r+patch.patch.shape[0],
            c:c+patch.patch.shape[1], :] = patch.overlay_image

    return img[:self.image.shape[0], :self.image.shape[1], :]</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Image.export_labels"><code class="name flex">
<span>def <span class="ident">export_labels</span></span>(<span>self, pathname)</span>
</code></dt>
<dd>
<div class="desc"><p>Export the labelling matrix</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong></dt>
<dd>The path to the labelling matrix file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>a .npy file will be saved at the specified path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_labels(self, pathname):
    &#34;&#34;&#34;
    Export the labelling matrix

    Args:
        pathname: The path to the labelling matrix file

    Returns:
        None

    Postconditions:
        a .npy file will be saved at the specified path
    &#34;&#34;&#34;

    self._create_labelling()
    np.save(pathname, self._landmark_matrix)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Image.export_mask"><code class="name flex">
<span>def <span class="ident">export_mask</span></span>(<span>self, pathname)</span>
</code></dt>
<dd>
<div class="desc"><p>Export the patch masks as a whole image mask</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathname</code></strong></dt>
<dd>The path to the mask image file to save as.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>A PNG image representing the mask will be saved at the
specified path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_mask(self, pathname):
    &#34;&#34;&#34;
    Export the patch masks as a whole image mask

    Args:
        pathname: The path to the mask image file to save as.

    Returns:
        None

    Postconditions:
        A PNG image representing the mask will be saved at the
        specified path.
    &#34;&#34;&#34;
    self._create_mask()

    # backup_path = os.path.splitext(pathname)[0]
    # backup_path += &#34;_bak.png&#34;
    # io.imsave(backup_path, img_as_uint(self.mask))

    # self._remove_small_components()
    io.imsave(pathname, img_as_uint(self.mask))</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Image.get_patch_from_coords"><code class="name flex">
<span>def <span class="ident">get_patch_from_coords</span></span>(<span>self, coords)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the index of the patch that contains the given coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>Coordinates in the original image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The index into the patches list of the corresponding patch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_patch_from_coords(self, coords):
    &#34;&#34;&#34;
    Get the index of the patch that contains the given coordinates.

    Args:
        coords: Coordinates in the original image.

    Returns:
        The index into the patches list of the corresponding patch.
    &#34;&#34;&#34;

    row = int(coords[0]/self._block_size[0])
    col = int(coords[1]/self._block_size[1])

    return row * self.num_patches + col</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Image.load_mask"><code class="name flex">
<span>def <span class="ident">load_mask</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a saved mask for the current image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The path to the mask file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_mask(self, path):
    &#34;&#34;&#34;
    Load a saved mask for the current image.

    Args:
        path: The path to the mask file.

    Returns:
        None
    &#34;&#34;&#34;
    # Load the mask
    mask = io.imread(path)
    mask = img_as_bool(mask)

    self._mask = mask

    # Figure out padding
    pad_x = (0, 0)
    pad_y = (0, 0)

    if mask.shape[0] % self.num_patches != 0:
        pad_x = (0, (self.num_patches - (mask.shape[0] %
                 self.num_patches)))

    if mask.shape[1] % self.num_patches != 0:
        pad_y = (0, (self.num_patches - (mask.shape[1] %
                 self.num_patches)))
    mask = np.pad(mask, (pad_x, pad_y), &#39;constant&#39;,
                  constant_values=(0, 0))

    # Split into blocks
    blocks = view_as_blocks(mask, block_shape=self._block_size)

    for i in range(self.num_patches):
        for j in range(self.num_patches):
            patch_data = blocks[i, j]

            self._patches[(i * self.num_patches) + j].mask = patch_data
            self._patches[(i * self.num_patches) + j]._overlay_mask()

            if self._progress_update_func is not None:
                self._progress_update_func()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="friendly_ground_truth.model.model.Patch"><code class="flex name class">
<span>class <span class="ident">Patch</span></span>
<span>(</span><span>patch, patch_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an image patch</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>threshold</code></strong></dt>
<dd>The current threshold for the mask</dd>
<dt><strong><code>patch</code></strong></dt>
<dd>The patch image data</dd>
<dt><strong><code>mask</code></strong></dt>
<dd>The mask for the patch</dd>
<dt><strong><code>patch_index</code></strong></dt>
<dd>The index of this patch in the original image</dd>
<dt><strong><code>overlay_image</code></strong></dt>
<dd>The patch image with the mask overlaid on top</dd>
<dt><strong><code>undo_history</code></strong></dt>
<dd>The undo history for this patch</dd>
</dl>
<p>Create a patch object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>patch</code></strong></dt>
<dd>The image data for the patch</dd>
<dt><strong><code>patch_index</code></strong></dt>
<dd>The index in the larger image of this patch</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A <a title="friendly_ground_truth.model.model.Patch" href="#friendly_ground_truth.model.model.Patch">Patch</a> object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Patch():
    &#34;&#34;&#34;
    Represents an image patch

    Attributes:
        threshold: The current threshold for the mask
        patch: The patch image data
        mask: The mask for the patch
        patch_index: The index of this patch in the original image
        overlay_image: The patch image with the mask overlaid on top
        undo_history: The undo history for this patch
    &#34;&#34;&#34;

    def __init__(self, patch, patch_index):
        &#34;&#34;&#34;
        Create a patch object

        Args:
            patch: The image data for the patch
            patch_index: The index in the larger image of this patch

        Returns:
            A Patch object
        &#34;&#34;&#34;

        self._logger = logging.getLogger(&#39;friendly_gt.model.Patch&#39;)

        self._patch = patch
        self._mask = np.zeros(self._patch.shape, dtype=bool)
        self._landmark_labels = np.zeros(self._patch.shape, dtype=np.uint8)

        self._patch_index = patch_index

        self._threshold = 1

        try:
            self.threshold = threshold_otsu(self._patch)
        except ValueError:
            self.threshold = 1

        self._overlay_image = None
        self._overlay_mask()

        self._old_flood_add_tolerance = 100
        self._old_flood_add_position = None

        self._old_flood_remove_tolerance = 100
        self._old_flood_remove_position = None

        self._undo_history = None

    @property
    def threshold(self):
        &#34;&#34;&#34;
        The current threshold value for the patch.


        Returns:
            The value of the current threshold.
        &#34;&#34;&#34;
        return self._threshold

    @threshold.setter
    def threshold(self, value):
        &#34;&#34;&#34;
        Set the threshold for this patch.

        Args:
            value: The value to set the threshold to.

        Returns:
            None

        Postconditions:
            The threshold will be applied to the mask.
            The overlay_image property will be updated to show the new mask.
        &#34;&#34;&#34;

        if value &gt;= 0 and value &lt;= 1:

            self._threshold = value
            self._apply_threshold(value)
            self._overlay_mask()

    @property
    def patch(self):
        &#34;&#34;&#34;
        The patch data for this patch.


        Returns:
            A numpy array representing the image data for this patch.
        &#34;&#34;&#34;
        return self._patch

    @property
    def mask(self):
        &#34;&#34;&#34;
        The current mask for this patch.


        Returns:
            A numpy array representing the mask for this patch.
        &#34;&#34;&#34;
        return self._mask

    @mask.setter
    def mask(self, mask):
        &#34;&#34;&#34;
        Set the mask.

        Args:
            mask: The new mask, a boolean numpy array.

        Returns:
            None
        &#34;&#34;&#34;
        self._mask = mask

    @property
    def landmark_labels(self):
        &#34;&#34;&#34;
        The landmark label matrix for this patch.


        Returns:
            A numpy array containing class labellings for pixels in this patch.
        &#34;&#34;&#34;
        return self._landmark_labels

    @property
    def patch_index(self):
        &#34;&#34;&#34;
        The index of this patch in the larger parent image matrix.


        Returns:
            A tuple (i, j), the row and column index for this patch.
        &#34;&#34;&#34;
        return self._patch_index

    @property
    def overlay_image(self):
        &#34;&#34;&#34;
        The overlay image displaying the mask on top of the patch image data.


        Returns:
            A numpy array colour image.
        &#34;&#34;&#34;
        return self._overlay_image

    @property
    def undo_history(self):
        return self._undo_history

    @undo_history.setter
    def undo_history(self, history):
        self._undo_history = history

    def _apply_threshold(self, value):
        &#34;&#34;&#34;
        Apply a threshold to the patch mask

        Args:
            value: The value for the threshold

        Returns:
            None

        Postconditions:
            The _mask property will be updated with the new threshold
            applied

        Raises:
            ValueError if the value is not between 0 and 1
        &#34;&#34;&#34;

        if value &gt; 1 or value &lt; 0:
            raise ValueError(&#34;Threshold values must be between 0 and 1&#34;)

        binary = self.patch &gt; value
        self._mask = binary

    def _overlay_mask(self):
        &#34;&#34;&#34;
        Overlay the current mask on the patch image


        Returns:
            None

        Postconditions:
            The _overlay_image property will contain the image with the
            binary mask over top.
        &#34;&#34;&#34;

        labeling = np.copy(self._landmark_labels)
        labeling += self.mask

        c1 = &#39;red&#39;
        c2 = &#39;green&#39;
        c3 = &#39;orange&#39;
        c4 = &#39;blue&#39;

        colours = []
        unique_labels = np.unique(labeling)

        mapping = [(1, c1), (2, c2), (3, c3), (4, c4)]

        for m in mapping:
            if m[0] in unique_labels:
                colours.append(m[1])

        if len(colours) &lt;= 0:
            colours = [&#39;purple&#39;]

        colour_mask = color.label2rgb(labeling, image=self._patch,
                                      colors=colours, bg_label=0)

        self._overlay_image = img_as_ubyte(colour_mask)

    def clear_mask(self):
        &#34;&#34;&#34;
        Clear the mask for this patch (set to all 0&#39;s)


        Returns:
            None

        Postconditions:
            The mask property will be reset to all 0&#39;s
        &#34;&#34;&#34;
        self._mask = np.zeros(self.patch.shape, dtype=bool)
        self.threshold = 1

    def add_landmark(self, position, radius, label):
        &#34;&#34;&#34;
        Label an area with the given label

        Args:
            position: The position to add the labelling (x, y)
            radius: The radius of a circle to label
            label: The class label for the pixels to be given

        Returns:
            None

        Postconditions:
            The _landmark_labels property will be udpated with the new
            landmark annotation.
        &#34;&#34;&#34;
        rr, cc = self._get_circle(position, radius)

        self._landmark_labels[rr, cc] = label

        # Don&#39;t mark anything that isn&#39;t foreground
        self._landmark_labels[self.mask == 0] = 0
        self._overlay_mask()

    def remove_landmark(self, position, radius):
        &#34;&#34;&#34;
        Un-label (label as 0) the pixels in the given region.


        Args:
            position: The position to un-label (x, y)
            radius: The radius of a circle to un-label

        Returns:
            None

        Postconditions:
            The _landmark_labels property will be updated with the new
            annotation.
        &#34;&#34;&#34;

        rr, cc = self._get_circle(position, radius)

        self._landmark_labels[rr, cc] = 0

        self._overlay_mask()

    def add_region(self, position, radius):
        &#34;&#34;&#34;
        Add a circular region to the mask at the given position.

        Args:
            position: The position to add the region (x, y)
            radius: The radius of the circular region

        Returns:
            None

        Postconditions:
            The _mask will be updated with the circular region set to 1&#39;s
        &#34;&#34;&#34;

        position = round(position[0]), round(position[1])

        self._logger.debug(&#34;Add Position: {}&#34;.format(position))
        rr, cc = self._get_circle(position, radius)

        self._mask[rr, cc] = 1

        self._overlay_mask()

    def remove_region(self, position, radius):
        &#34;&#34;&#34;
        Remove a circular region from the mask at the given position.

        Args:
            position: The position to remove the region at (x, y)
            radius: The radius of the circular region

        Returns:
            None

        Postconditions:
            The _mask will be updated with the circular region set to 0&#39;s
        &#34;&#34;&#34;
        rr, cc = self._get_circle(position, radius)

        self._mask[rr, cc] = 0

        self._overlay_mask()

    def flood_add_region(self, position, tolerance):
        &#34;&#34;&#34;
        Add to the current mask a flood region at the given position with the
        given tolerance.


        Args:
            position: The position to start the flood fill (x, y)
            tolerance: The tolerance for pixels to be included

        Returns:
            None

        Postconditions:
            The _mask will be updated with the new region.
        &#34;&#34;&#34;

        from skimage.segmentation import flood

        position = int(position[0]), int(position[1])

        # If we are still editing the tolerance, we need to go back to the old
        # mask.
        if position == self._old_flood_add_position:
            self.mask = np.copy(self._old_mask)
        else:
            self._old_mask = np.copy(self._mask)

        add_mask = flood(self._patch, position, tolerance=tolerance)

        self._mask += add_mask

        self._overlay_mask()

        self._old_flood_add_tolerance = tolerance
        self._old_flood_add_position = position

    def flood_remove_region(self, position, tolerance):
        &#34;&#34;&#34;
        Remove from the current mask a flood region at the given position with
        the given tolerance.

        Args:
            position: The position to start the flood fill (x, y)
            tolerance: The tolerance for pixels to be included

        Returns:
            None

        Postconditions:
            The _mask will be updated with the new region
        &#34;&#34;&#34;
        from skimage.segmentation import flood

        position = int(position[0]), int(position[1])

        # If we are still editing the tolerance, we need to go back to the old
        # mask.
        if position == self._old_flood_remove_position:
            self.mask = np.copy(self._old_mask)
        else:
            self._old_mask = np.copy(self._mask)

        remove_mask = flood(self._patch, position, tolerance=tolerance)

        self._mask[remove_mask] = 0

        self._overlay_mask()

        self._old_flood_remove_tolerance = tolerance
        self._old_flood_remove_position = position

    def _get_circle(self, position, radius):
        &#34;&#34;&#34;
        Return the indices of a circular region at the given position with the
        given radius.

        Args:
            position: (x, y) coordinates of the circle
            radius: The radius of the circle

        Returns:
            Two lists, rr and cc that represnt points in the circle
        &#34;&#34;&#34;

        rr, cc = circle(position[0], position[1], radius)

        zipped = zip(rr, cc)

        fixed_pairs = []

        for pair in zipped:
            if (pair[0] &gt;= 0 and pair[1] &gt;= 0 and pair[0] &lt; self._mask.shape[0]
                    and pair[1] &lt; self.mask.shape[1]):
                fixed_pairs.append(pair)

        rr = []
        cc = []

        for p in fixed_pairs:
            rr.append(p[0])
            cc.append(p[1])

        return rr, cc</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="friendly_ground_truth.model.model.Patch.landmark_labels"><code class="name">var <span class="ident">landmark_labels</span></code></dt>
<dd>
<div class="desc"><p>The landmark label matrix for this patch.</p>
<h2 id="returns">Returns</h2>
<p>A numpy array containing class labellings for pixels in this patch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def landmark_labels(self):
    &#34;&#34;&#34;
    The landmark label matrix for this patch.


    Returns:
        A numpy array containing class labellings for pixels in this patch.
    &#34;&#34;&#34;
    return self._landmark_labels</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.mask"><code class="name">var <span class="ident">mask</span></code></dt>
<dd>
<div class="desc"><p>The current mask for this patch.</p>
<h2 id="returns">Returns</h2>
<p>A numpy array representing the mask for this patch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mask(self):
    &#34;&#34;&#34;
    The current mask for this patch.


    Returns:
        A numpy array representing the mask for this patch.
    &#34;&#34;&#34;
    return self._mask</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.overlay_image"><code class="name">var <span class="ident">overlay_image</span></code></dt>
<dd>
<div class="desc"><p>The overlay image displaying the mask on top of the patch image data.</p>
<h2 id="returns">Returns</h2>
<p>A numpy array colour image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def overlay_image(self):
    &#34;&#34;&#34;
    The overlay image displaying the mask on top of the patch image data.


    Returns:
        A numpy array colour image.
    &#34;&#34;&#34;
    return self._overlay_image</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>The patch data for this patch.</p>
<h2 id="returns">Returns</h2>
<p>A numpy array representing the image data for this patch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def patch(self):
    &#34;&#34;&#34;
    The patch data for this patch.


    Returns:
        A numpy array representing the image data for this patch.
    &#34;&#34;&#34;
    return self._patch</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.patch_index"><code class="name">var <span class="ident">patch_index</span></code></dt>
<dd>
<div class="desc"><p>The index of this patch in the larger parent image matrix.</p>
<h2 id="returns">Returns</h2>
<p>A tuple (i, j), the row and column index for this patch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def patch_index(self):
    &#34;&#34;&#34;
    The index of this patch in the larger parent image matrix.


    Returns:
        A tuple (i, j), the row and column index for this patch.
    &#34;&#34;&#34;
    return self._patch_index</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.threshold"><code class="name">var <span class="ident">threshold</span></code></dt>
<dd>
<div class="desc"><p>The current threshold value for the patch.</p>
<h2 id="returns">Returns</h2>
<p>The value of the current threshold.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def threshold(self):
    &#34;&#34;&#34;
    The current threshold value for the patch.


    Returns:
        The value of the current threshold.
    &#34;&#34;&#34;
    return self._threshold</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.undo_history"><code class="name">var <span class="ident">undo_history</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def undo_history(self):
    return self._undo_history</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.model.model.Patch.add_landmark"><code class="name flex">
<span>def <span class="ident">add_landmark</span></span>(<span>self, position, radius, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Label an area with the given label</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>The position to add the labelling (x, y)</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>The radius of a circle to label</dd>
<dt><strong><code>label</code></strong></dt>
<dd>The class label for the pixels to be given</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The _landmark_labels property will be udpated with the new
landmark annotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_landmark(self, position, radius, label):
    &#34;&#34;&#34;
    Label an area with the given label

    Args:
        position: The position to add the labelling (x, y)
        radius: The radius of a circle to label
        label: The class label for the pixels to be given

    Returns:
        None

    Postconditions:
        The _landmark_labels property will be udpated with the new
        landmark annotation.
    &#34;&#34;&#34;
    rr, cc = self._get_circle(position, radius)

    self._landmark_labels[rr, cc] = label

    # Don&#39;t mark anything that isn&#39;t foreground
    self._landmark_labels[self.mask == 0] = 0
    self._overlay_mask()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.add_region"><code class="name flex">
<span>def <span class="ident">add_region</span></span>(<span>self, position, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a circular region to the mask at the given position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>The position to add the region (x, y)</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>The radius of the circular region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The _mask will be updated with the circular region set to 1's</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_region(self, position, radius):
    &#34;&#34;&#34;
    Add a circular region to the mask at the given position.

    Args:
        position: The position to add the region (x, y)
        radius: The radius of the circular region

    Returns:
        None

    Postconditions:
        The _mask will be updated with the circular region set to 1&#39;s
    &#34;&#34;&#34;

    position = round(position[0]), round(position[1])

    self._logger.debug(&#34;Add Position: {}&#34;.format(position))
    rr, cc = self._get_circle(position, radius)

    self._mask[rr, cc] = 1

    self._overlay_mask()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.clear_mask"><code class="name flex">
<span>def <span class="ident">clear_mask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the mask for this patch (set to all 0's)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The mask property will be reset to all 0's</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_mask(self):
    &#34;&#34;&#34;
    Clear the mask for this patch (set to all 0&#39;s)


    Returns:
        None

    Postconditions:
        The mask property will be reset to all 0&#39;s
    &#34;&#34;&#34;
    self._mask = np.zeros(self.patch.shape, dtype=bool)
    self.threshold = 1</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.flood_add_region"><code class="name flex">
<span>def <span class="ident">flood_add_region</span></span>(<span>self, position, tolerance)</span>
</code></dt>
<dd>
<div class="desc"><p>Add to the current mask a flood region at the given position with the
given tolerance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>The position to start the flood fill (x, y)</dd>
<dt><strong><code>tolerance</code></strong></dt>
<dd>The tolerance for pixels to be included</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The _mask will be updated with the new region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flood_add_region(self, position, tolerance):
    &#34;&#34;&#34;
    Add to the current mask a flood region at the given position with the
    given tolerance.


    Args:
        position: The position to start the flood fill (x, y)
        tolerance: The tolerance for pixels to be included

    Returns:
        None

    Postconditions:
        The _mask will be updated with the new region.
    &#34;&#34;&#34;

    from skimage.segmentation import flood

    position = int(position[0]), int(position[1])

    # If we are still editing the tolerance, we need to go back to the old
    # mask.
    if position == self._old_flood_add_position:
        self.mask = np.copy(self._old_mask)
    else:
        self._old_mask = np.copy(self._mask)

    add_mask = flood(self._patch, position, tolerance=tolerance)

    self._mask += add_mask

    self._overlay_mask()

    self._old_flood_add_tolerance = tolerance
    self._old_flood_add_position = position</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.flood_remove_region"><code class="name flex">
<span>def <span class="ident">flood_remove_region</span></span>(<span>self, position, tolerance)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove from the current mask a flood region at the given position with
the given tolerance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>The position to start the flood fill (x, y)</dd>
<dt><strong><code>tolerance</code></strong></dt>
<dd>The tolerance for pixels to be included</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The _mask will be updated with the new region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flood_remove_region(self, position, tolerance):
    &#34;&#34;&#34;
    Remove from the current mask a flood region at the given position with
    the given tolerance.

    Args:
        position: The position to start the flood fill (x, y)
        tolerance: The tolerance for pixels to be included

    Returns:
        None

    Postconditions:
        The _mask will be updated with the new region
    &#34;&#34;&#34;
    from skimage.segmentation import flood

    position = int(position[0]), int(position[1])

    # If we are still editing the tolerance, we need to go back to the old
    # mask.
    if position == self._old_flood_remove_position:
        self.mask = np.copy(self._old_mask)
    else:
        self._old_mask = np.copy(self._mask)

    remove_mask = flood(self._patch, position, tolerance=tolerance)

    self._mask[remove_mask] = 0

    self._overlay_mask()

    self._old_flood_remove_tolerance = tolerance
    self._old_flood_remove_position = position</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.remove_landmark"><code class="name flex">
<span>def <span class="ident">remove_landmark</span></span>(<span>self, position, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Un-label (label as 0) the pixels in the given region.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>The position to un-label (x, y)</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>The radius of a circle to un-label</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The _landmark_labels property will be updated with the new
annotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_landmark(self, position, radius):
    &#34;&#34;&#34;
    Un-label (label as 0) the pixels in the given region.


    Args:
        position: The position to un-label (x, y)
        radius: The radius of a circle to un-label

    Returns:
        None

    Postconditions:
        The _landmark_labels property will be updated with the new
        annotation.
    &#34;&#34;&#34;

    rr, cc = self._get_circle(position, radius)

    self._landmark_labels[rr, cc] = 0

    self._overlay_mask()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.model.model.Patch.remove_region"><code class="name flex">
<span>def <span class="ident">remove_region</span></span>(<span>self, position, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a circular region from the mask at the given position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>The position to remove the region at (x, y)</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>The radius of the circular region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The _mask will be updated with the circular region set to 0's</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_region(self, position, radius):
    &#34;&#34;&#34;
    Remove a circular region from the mask at the given position.

    Args:
        position: The position to remove the region at (x, y)
        radius: The radius of the circular region

    Returns:
        None

    Postconditions:
        The _mask will be updated with the circular region set to 0&#39;s
    &#34;&#34;&#34;
    rr, cc = self._get_circle(position, radius)

    self._mask[rr, cc] = 0

    self._overlay_mask()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="friendly_ground_truth.model" href="index.html">friendly_ground_truth.model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="friendly_ground_truth.model.model.Image" href="#friendly_ground_truth.model.model.Image">Image</a></code></h4>
<ul class="">
<li><code><a title="friendly_ground_truth.model.model.Image.BG_LABEL" href="#friendly_ground_truth.model.model.Image.BG_LABEL">BG_LABEL</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.BRANCH_LABEL" href="#friendly_ground_truth.model.model.Image.BRANCH_LABEL">BRANCH_LABEL</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.CROSS_LABEL" href="#friendly_ground_truth.model.model.Image.CROSS_LABEL">CROSS_LABEL</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.TIP_LABEL" href="#friendly_ground_truth.model.model.Image.TIP_LABEL">TIP_LABEL</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.create_overlay_img" href="#friendly_ground_truth.model.model.Image.create_overlay_img">create_overlay_img</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.export_labels" href="#friendly_ground_truth.model.model.Image.export_labels">export_labels</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.export_mask" href="#friendly_ground_truth.model.model.Image.export_mask">export_mask</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.get_patch_from_coords" href="#friendly_ground_truth.model.model.Image.get_patch_from_coords">get_patch_from_coords</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.image" href="#friendly_ground_truth.model.model.Image.image">image</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.load_mask" href="#friendly_ground_truth.model.model.Image.load_mask">load_mask</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.mask" href="#friendly_ground_truth.model.model.Image.mask">mask</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.num_patches" href="#friendly_ground_truth.model.model.Image.num_patches">num_patches</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.patches" href="#friendly_ground_truth.model.model.Image.patches">patches</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Image.path" href="#friendly_ground_truth.model.model.Image.path">path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="friendly_ground_truth.model.model.Patch" href="#friendly_ground_truth.model.model.Patch">Patch</a></code></h4>
<ul class="two-column">
<li><code><a title="friendly_ground_truth.model.model.Patch.add_landmark" href="#friendly_ground_truth.model.model.Patch.add_landmark">add_landmark</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.add_region" href="#friendly_ground_truth.model.model.Patch.add_region">add_region</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.clear_mask" href="#friendly_ground_truth.model.model.Patch.clear_mask">clear_mask</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.flood_add_region" href="#friendly_ground_truth.model.model.Patch.flood_add_region">flood_add_region</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.flood_remove_region" href="#friendly_ground_truth.model.model.Patch.flood_remove_region">flood_remove_region</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.landmark_labels" href="#friendly_ground_truth.model.model.Patch.landmark_labels">landmark_labels</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.mask" href="#friendly_ground_truth.model.model.Patch.mask">mask</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.overlay_image" href="#friendly_ground_truth.model.model.Patch.overlay_image">overlay_image</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.patch" href="#friendly_ground_truth.model.model.Patch.patch">patch</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.patch_index" href="#friendly_ground_truth.model.model.Patch.patch_index">patch_index</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.remove_landmark" href="#friendly_ground_truth.model.model.Patch.remove_landmark">remove_landmark</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.remove_region" href="#friendly_ground_truth.model.model.Patch.remove_region">remove_region</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.threshold" href="#friendly_ground_truth.model.model.Patch.threshold">threshold</a></code></li>
<li><code><a title="friendly_ground_truth.model.model.Patch.undo_history" href="#friendly_ground_truth.model.model.Patch.undo_history">undo_history</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>